            **** Rails ****


    1. Rails is an open source web framework that uses ruby programming language.

    2. Framework vs Library:  libraries target a specific functionality, while a framework tries to provide everything required to develop a complete application.

    3. Major principles of rails: - DRY (Don't Repeat Yourself) : Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
                                  - Rails has opinions about the best way to do many things in a web application, and defaults to this set of conventions, rather than require that you specify minutiae through endless configuration files.

    4. MVC Architecture: MVC stands for Model View Controller Architecture. It helps in ensuring DRY principal is followed.

        - Model: Contains all the database related objects and business logic
        - View: Contains all the objects that will be shown to the user like html css js.
        - Controller: Contains all the code that will help in decision making process for a given request

        Working:
        - Request from browser will be sent too Controller for decision making
        - Controller will then ask the result of request from model which will be connected to the db 
        - then after recieving the result controller will show results to user using the View object.

    5. Create a new project: Command: rails new <application-name>

        To start the server : rails server

        by default this project is using sqlite3 db

        when we have to create a project using postgres as db command is:

        rails new <application-name> -d postgresql

        before starting the server we have to initialize the db which is done using the command:

        rake db:create

        then start the server using: rails server

    6. Most of the coding is done in the app folder(95%) followed by config dir, gem file(packages used by our project) and db dir(database related files like db migration).

    7. We have different files for production,development,test environment inside the config dir.

    8. Generate controller: Command : rails generate controller Demo[Controller-name] index[List of views]
        
        this command will generate a new controller in the controller folder of app and also a view inside view folder (demo/index)
        also in the config file we will have a route created in routes.rb file showing that demo controller is associated with index view

    9. Rails Architecture(MVC arch explained wrt reality): Browser sends request using a web server(eg: apache) to the application.
        Now application before sending the req to rail framework checks that whether the asked path is present insdie the public folder or not.
        if it is present then the req is returned through public folder only and if it is not then the req is sent to the rails framework.

        Any file inside public folder is visible for users.

    10. Routing: It helps in determining which controller to be called according to the request.
        In short helps in determining the routes. routes.rb has all the routes which is present in the config folder

        Types of routes:
            -simple match route
            -default route
            -root route
            -resourceful routes

        Simple match route: Syntax: get "demo/index"
                                    or
                                    match "demo/index", :to => "demo#index", :via => :get (this is useful when we have to keep diff path name than controller name and view name)

        Default route: Syntax: get ":controller(/:action(/:id))"
                               or
                               match ':controller(/:action(/:id))', :via => :get

        root route: Syntax: root "demo#index"
                            or
                            match "/", :to => "demo#index", :via => :get

    11. Rendering templates: the routes defined help in deciding the controller and action(method in controller).
        and then the template is rendered using default behaviour as Controller name as folder and action name as filename to choose the template.

        to render according to our own wish we may use render("path") inside the action
        Example:
            class DemoController < ApplicationController
            layout false

            def index
                render('demo/hello')
            end

            def hello
                render('demo/index')
            end
            end

    12. Redirect: When we recieve a request and controller instead of sending view as a response sends request to another controller 
        for eg: trying to access a page that rquires login without loggin in that will send user to login screen first

        Redirect changes the url link.    

        Example:
        class DemoController < ApplicationController
        def index
        end

        def hello
            redirect_to(controller:"demo",action:"index")
        end
        end

        hello action will redirect to index everytime

        We can also write : redirect_to(action:"index")
        if the controller is same

    13. What is erb?: Embedded ruby(used to write ruby code in html file)

        Syntax: <% code %> (it doesnot outputs the result on template)
                or
                <%= code %> (it outputs the result)

        Example:
        <h1>Index page</h1>

        <%= "printss 1" %>

        <br />

        <% set = "Hello" %>

        <%= "Hello #{set}" %>

        <% 3.times do |n| %>
            <p><%= n %></p>
        <% end %>

        Output:
        Index page
        printss 1
        Hello Hello
        0

        1

        2

    14. instance variables: start with @ and can be shared by the class and belong to one instance of the class
        Can be used in the templates(views)
        Example:
        <% @array.each do |n| %>
            <p><%= n %></p>
        <% end %>

    15. Links: use to navigate to another webpage. similar to anchor tag in html
        Syntax: <%= link_to("display name of link","path") %>
                or
                <%= link_to("display name of link",{:controller => name , :action => name}) %>

        Example:
        <h1>hello page</h1>

        <a href = "/demo/index"> index page 1</a>

        <br /> <br />

        <%= link_to("Index page 2",{:action => "index"}) %>

    16. URL Parameters: parameters are usually content that appears in the link after '?'
        params are stored in rails frame work in 'params' variable.

        Exmple:
        hello.html.erb file

        <%= link_to("Index page 2",{:action => "index" , :id => 30 , :page =>444}) %>

        index.html.erb file

        ID: <%= params['id'] %> 
        Page: <%= @page %>

        controller file

        class DemoController < ApplicationController
        def index
            @array = [1,2,3,4,5]
            @page = params['page']
        end

        def hello
            
            #redirect_to(controller:"demo",action:"index")
        end
        end

        We can access parameters from params var both by 'str' and :str way. and these params are stored as strings in rails

    17. Autoloading: Application classes and modules are available everywhere, you do not need and should not load anything under app with require. 
            require "application_controller" # DON'T DO THIS.

    18. Model: A model is a Ruby class that is used to represent data. Additionally, models can interact with the application's database 
            through a feature of Rails called Active Record.

                - Generating a model: Syntax: bin/rails generate model Article(model_name) title:string body:text(attributes)

                out of the created files we work in two files one is migrate file which contains the description of the table created
                other one is inside the model which is used for validations 

                - Migrating a model: Migrations are used to alter the structure of an application's database.
                With migration we can interact with our database/table through our model in console no need to write sql.

                Syntax: rails db:migrate

                - interacting with db: We have to open console using command: bin/rails console

                    1. new: To create new record  
                        Eg: article = Article.new(title: "Hello Rails", body: "I am on Rails!")

                    2. save: new will only create new record to save the record in table in db we have to use save method
                        Eg: article.save

                    3. create: it creates a new entry as well ass adds it to the table.

                    4. find: finds specific id from table.
                        Eg: Article.find(1)

                    5. all: List all records in the table
                        Eg: Article.all


    19. Showing table in templates: We can do this by calling the model class in our controller as
            
            class DemoController < ApplicationController
            def index
                @arr = Demo.all
            end
            end

        Then calling this instance var in view file using erb format as:
            
            <% @arr.each do |rec| %>
                <p><%= rec[:name] %></p>
            <% end %>

    20. Resourceful Routing: Rails provides a routes method named resources that maps all of the conventional routes 
    for a collection of resources, such as articles.

        Syntax:
        Rails.application.routes.draw do
        # get 'demo/index'
        resources :demo
        # match 'demo/:id', :to => 'demo#show', :via => :get
        # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

        # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
        # Can be used by load balancers and uptime monitors to verify that the app is live.
        get "up" => "rails/health#show", as: :rails_health_check

        # Defines the root path route ("/")
        # root "posts#index"
        end

    We can inspect what routes are mapped by running the bin/rails routes command:
        bin/rails routes
            Prefix Verb   URI Pattern                  Controller#Action
                root GET    /                            articles#index
            articles GET    /articles(.:format)          articles#index
        new_article GET    /articles/new(.:format)      articles#new
            article GET    /articles/:id(.:format)      articles#show
                    POST   /articles(.:format)          articles#create
        edit_article GET    /articles/:id/edit(.:format) articles#edit
                    PATCH  /articles/:id(.:format)      articles#update
                    DELETE /articles/:id(.:format)      articles#destroy

    21. Active Record: Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. 
    Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database. basically helps in db creation migration etc.

        - ORM: Object Relational Mapping, commonly referred to as its abbreviation ORM.
            Using ORM, the properties and relationships of the objects in an application can be easily stored and retrieved from a database without writing SQL statements 
            directly and with less overall database access code.

        - Convention over configuration:
            1. naming convention: model name singular(Article,person) , table name plural(Articles,people)
            2. schema conventions: Foreign keys - These fields should be named following the pattern singularized_table_name_id (e.g., item_id, order_id). 
            These are the fields that Active Record will look for when you create associations between your models.
            Primary keys - By default, Active Record will use an integer column named id as the table's primary key

        - Application record: When generating an application, an abstract ApplicationRecord class will be created in app/models/application_record.rb. 
        This is the base class for all models in an app, and it's what turns a regular ruby class into an Active Record model. When we create a model it automatically inherits from ApplicationRecord

        Creating a model and creating an active record model is same.

        - Overriding naming conventions: Since ApplicationRecord inherits from ActiveRecord::Base, your application's models will have a number of helpful methods available to them. 
        For example, you can use the ActiveRecord::Base.table_name= method to customize the table name that should be used:
        Example:
        class Product < ApplicationRecord
        self.table_name = "my_products"
        end

        If you do so, you will have to manually define the class name that is hosting the fixtures (my_products.yml) using the set_fixture_class method in your test definition:

    22. CRUD: CREATE READ UPDATE DELETE

        -Create: user = User.create(name: "David", occupation: "Code Artist")
                 or
                 user = User.new
                 user.save

        -Read:  users = User.all
                or
                user = User.first
                or
                david = User.find_by(name: 'David')
                or
                users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)

        -Update: user = User.find_by(name: 'David')
                 user.update(name: 'Dave')
                 or
                 User.update_all attribute:val 

        -Delete:user = User.find_by(name: 'David')
                user.destroy
                or
                User.destroy_by(name: 'David')
                User.destroy_all

            
    23. Migration: Migrations are a convenient way to alter your database schema over time in a consistent way. 
    They use a Ruby DSL so that you don't have to write SQL by hand, allowing your schema and changes to be database independent.

        -Migrations are stored as files in the db/migrate directory, one for each migration class. 
        The name of the file is of the form YYYYMMDDHHMMSS_create_products.rb

        - Generating a migration: bin/rails generate migration AddDetailsToProducts name:string age:string

        - Removing a column from table: bin/rails generate migration RemovePartNumberFromProducts part_number:string

        - Create a table: bin/rails generate migration CreateProducts name:string part_number:string

            Not recommend this instead use generate model to create a new table

        - Add Foriegn Key to a table: bin/rails generate migration AddUserRefToProducts user:references

            Adds user_id col to Products which is a Fk for this table and pk from user table.

        - db folder: Migrate folder is present here which is responsible for every change in db. Every altercation in db we have to create a new migration old ones cant be migrated again.

        - Writing migrations: We can edit the migrations file before migrating it and reflecting it in our dbs.

        - Composite primary keys: we can add composite pk to a table by adding :primary_key option to the create table method in change method 
            Example:
            class CreateProducts < ActiveRecord::Migration[7.1]
            def change
                create_table :products, primary_key: [:customer_id, :product_sku] do |t|
                t.integer :customer_id
                t.string :product_sku
                t.text :description
                end
            end
            end

        - Sometimes helpers are not enough that are provided bu active records to edit the database so we can 
        execute sql queries to in the console using special method.([Class].connection.execute)

            Example: Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1") 

        - revert migration: We can revert any migration by creating new migration and using revert functionality.

            Example:
            require_relative "20231123110831_add_product_ref_to_customers"

            class RevertAddProductRef < ActiveRecord::Migration[7.1]
              def change
                revert AddProductRefToCustomers
              end
            end

        - run a specific migration : bin/rails db:migrate VERSION=20080906120000

        - rollback: bin/rails db:rollback STEP=3

            if needed to rollback to only 1 step then remove STEP=3

        - redo: The db:migrate:redo command is a shortcut for doing a rollback and then migrating back up again

        - setup db: The bin/rails db:setup command will create the database, load the schema, and initialize it with the seed data.

        - prepare: The bin/rails db:prepare command is similar to bin/rails db:setup, but it operates idempotently.

        - reset: The bin/rails db:reset command will drop the database and set it up again. This is functionally equivalent to bin/rails db:drop db:setup.

        - run migration in different environments: bin/rails db:migrate RAILS_ENV=test

            by default it runs in development environment
        
        - check status of migrations: bin/rails db:migrate:status

    24. Validations: Validations are used to ensure that only valid data is saved into your database.

        - The following methods trigger validations, and will save the object to the database only if the object is valid:
            - create
            - create!
            - save
            - save!
            - update
            - update!

        - The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.
            - decrement!
            - decrement_counter
            - increment!
            - increment_counter
            - insert
            - insert!
            - insert_all
            - insert_all! 
            - etc
        
        - valid? : to check the validity of the record to be entered
            irb> Person.create(name: "John Doe").valid?
            => true
            irb> Person.create(name: nil).valid?
            => false

        - Note that an object instantiated with new will not report errors even if it's technically invalid, because validations are automatically run only when the object is saved,
         such as with the create or save methods.

        - acceptance: used in checkbox to check that value is checked or not.

        - comparison: used to compare two attributes.
            Example: validates :end, comparison: { greater_than: :start }

        - confirmation: to check that two values entered are equal or not like re enter password situation.

        - format:  validates the attributes' values by testing whether they match a given regular expression.

        - inclusion: only allows value in the list.

        - exclusion: inclusion!

        - length: decide the length of the record to be entered.

        - numericality: to ensure only valid numbers are entered.

        - presence: value cannot be nil.

        - absence: presence!

        - uniqueness

    
    25. Options in Validation: 
        - :allow_nil: Skip validation if the attribute is nil.
        
        - :allow_blank: Skip validation if the attribute is blank.
        
        - :message: Specify a custom error message.
        
        - :on: Specify the contexts where this validation is active.

        - :strict: Raise an exception when the validation fails.
        Example:
        class Person < ApplicationRecord
        validates :name, presence: { strict: true }
        end

        irb> Person.new.valid?
        ActiveModel::StrictValidationFailed: Name can't be blank

    26. Conditional Validation: Sometimes it will make sense to validate an object only when a given predicate is satisfied. 
    You can do that by using the :if and :unless option.

        - Using a Symbol with :if and :unless:

            Example:
            validates :adhar_number, presence: true, if: :mobile_pres

            def mobile_pres
                mobile.empty? == false
            end
            
            op:
            3.0.0 :074 > c.errors.objects.first.full_message
            => "Adhar number can't be blank" 

        - Using a Proc with :if and :unless

            Example:
            validates :adhar_number, presence: true, unless: Proc.new{|obj| obj.mobile.empty?}

            op:
            3.0.0 :088 > c = Customer.new(name:"Ishita",mobile:"9971")
            => 
            #<Customer:0x00007f2837561740
            ... 
            3.0.0 :089 > c.valid?
            => false

        - Grouping Conditional Validations: Sometimes it is useful to have multiple validations use one condition. It can be easily achieved using with_options.

            Example:

            class User < ApplicationRecord
            with_options if: :is_admin? do |admin|
                admin.validates :password, length: { minimum: 10 }
                admin.validates :email, presence: true
            end
            end

        - Combining Validation Conditions: On the other hand, when multiple conditions define whether or not a validation should happen, an Array can be used. Moreover, you can apply both :if and :unless to the same validation.

            Example:
            class Computer < ApplicationRecord
            validates :mouse, presence: true, if: [Proc.new { |c| c.market.retail? }, :desktop?], unless: Proc.new { |c| c.trackpad.present? }

    27. Custom Validators: Custom validators are classes that inherit from ActiveModel::Validator. These classes must implement the validate method which takes a record as an argument and performs the validation on it.

        Example:
        class MyValidator < ActiveModel::Validator
            def validate(record)
                unless record.name.start_with? 'X'
                    record.errors.add :name, "Provide a name starting with X, please!"
                end
            end
        end

        class Customer < ApplicationRecord

            validates_with MyValidator
        end

    28. Cutom methods: You can also create methods that verify the state of your models and add errors to the errors collection when they are invalid. You must then register these methods by using the validate class

        Example:
        class Invoice < ApplicationRecord
        validate :expiration_date_cannot_be_in_the_past,
            :discount_cannot_be_greater_than_total_value

        def expiration_date_cannot_be_in_the_past
            if expiration_date.present? && expiration_date < Date.today
            errors.add(:expiration_date, "can't be in the past")
            end
        end

        def discount_cannot_be_greater_than_total_value
            if discount > total_value
            errors.add(:discount, "can't be greater than total value")
            end
        end
        end

        - If you want to find out all of the validators for a given objects, look no further than validators.
            - Customer.validators
             => [#<MyValidator:0x00007f2492327b58 @options={}>] 

    29. Errors: 
        - errors: 3.0.0 :028 > c.errors
                 => #<ActiveModel::Errors [#<ActiveModel::Error attribute=name, type=blank, options={:message=>"name cant be empty"}>]> 

                3.0.0 :029 > c.errors.full_messages
                => ["Name name cant be empty"] 

                3.0.0 :030 > c.errors.first.details
                => {:error=>:blank}

        - errors[]: 3.0.0 :031 > c.errors[:name]
                     => ["name cant be empty"] 

        - where: where returns an array of error objects filtered by various degrees of conditions
                3.0.0 :032 > error = c.errors.where(:name).last
                => #<ActiveModel::Error attribute=name, type=blank, options={:message=>"name cant be empty"}> 
                3.0.0 :033 > error.message
                => "name cant be empty" 
                3.0.0 :034 > error.full_message
                => "Name name cant be empty" 

        - add: The add method creates the error object by taking the attribute, the error type and additional options hash. 
                class Person < ApplicationRecord
                validate do |person|
                    errors.add :name, :too_plain, message: "is not cool enough"
                end
                end

                3.0.0 :043 > c.errors.full_messages
                => ["Name name cant be empty", "Name is not cool enough"] 

        - size & clear: The clear method is used when you intentionally want to clear the errors collection. 
        Of course, calling errors.clear upon an invalid object won't actually make it valid: the errors collection will now be empty, 
        but the next time you call valid? or any method that tries to save this object to the database, the validations will run again. 
        If any of the validations fail, the errors collection will be filled again.

                3.0.0 :051 > c.errors.size
                => 2 
                3.0.0 :052 > c.errors.clear
                => [] 
                3.0.0 :053 > c.errors.size
                => 0 

        
    30. Callbacks: Callbacks are methods that get called at certain moments of an object's life cycle. 
    With callbacks it is possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.

        Example:
        class Baby < ApplicationRecord
        after_create -> { puts "Congratulations!" }
        end

        irb> @baby = Baby.create
        Congratulations!

        - Callbacks Registration: In order to use the available callbacks, you need to register them. 
        You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks
        
        Example:
            after_create :creation

            private
                def creation
                    puts "Product added successfully"            
                end

        - available callbacks:
            1. Creating an Object
                before_validation
                after_validation
                before_save
                around_save
                before_create
                around_create
                after_create
                after_save
                after_commit / after_rollback

            2. Updating an Object
                before_validation
                after_validation
                before_save
                around_save
                before_update
                around_update
                after_update
                after_save
                after_commit / after_rollback

            3. Destroying an Object
                before_destroy
                around_destroy
                after_destroy
                after_commit / after_rollback

            4. after_initialize
            
            5. after_find

            6. after_touch

        - Methods that trigger callbacks: The following methods trigger callbacks:
            create
            create!
            destroy
            destroy!
            destroy_all
            destroy_by
            save
            save!
            save(validate: false)
            toggle!
            touch
            update_attribute
            update
            update!
            valid?
            
            Additionally, the after_find callback is triggered by the following finder methods:
            all
            first
            find
            find_by
            find_by_*
            find_by_*!
            find_by_sql
            last

            The after_initialize callback is triggered every time a new object of the class is initialized.

        - Skipping Callbacks: Just as with validations, it is also possible to skip callbacks by using the following methods:
            decrement!
            decrement_counter
            delete
            delete_all
            delete_by
            increment!
            increment_counter
            insert
            insert!
            insert_all
            insert_all!
            touch_all
            update_column
            update_columns
            update_all
            update_counters
            upsert
            upsert_all

    31. Throw errors: if error is thrown then the queue having validations and callbacks is rolled back.

    32. Conditional callbacks: As with validations, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. 
    We can do this using the :if and :unless options, which can take a symbol, a Proc or an Array.

        - if and unless with a proc:
            Example:
            before_create :fn , if: Proc.new { name.length==6 }
            def fn 
                puts "word is of length #{name}"
            end

        TO ACCESS ATTRIBUTE BEIGN GIVEN WE CAN SIMPLY DO IT USING ATTRIBUTE NAME LIKE ABOVE WE HAVE FOUND LENGTH OF NAME BEIGN ENTERED BY THE USER.

        - if and unless with a :function in place of proc

        - multiple conditions can be entered like if: [cond1,cond2]

        - if and unless can be used together too.

    
    33. Callback classes: Sometimes the callback methods that you'll write will be useful enough to be reused by other models. 
    Active Record makes it possible to create classes that encapsulate the callback methods, so they can be reused.

        Example:
        class OurCallbackClass
            def before_create(record)
                if record.name.length>2
                    puts "length is greater than 2"
                end
            end
        end

        class Product < ApplicationRecord
            before_create OurCallbackClass.new
        end

    34. Associations: In Rails, an association is a connection between two Active Record models. 
        
        - They make common operations simpler and easier in your code.In Rails, an association is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code.

        Example:
        Create two table author and books and add reference between them using migration
        class AddAuthRefToBooks < ActiveRecord::Migration[7.1]
        def change
            add_reference :books, :author, null: false, foreign_key: true
        end
        end

        in model folder specify the type of relation to perform operations on both models simultaeously and easily.

        class Author < ApplicationRecord
        has_many :books, dependent: :destroy
        end

        class Book < ApplicationRecord
        belongs_to :author
        end

        - Types of association:
        
        1. belongs_to: A belongs_to association sets up a connection with another model, such that each instance of the declaring model "belongs to" one instance of the other model.
            Example:
            class Book < ApplicationRecord
            belongs_to :author
            end

        2. has_one: A has_one association indicates that one other model has a reference to this model.
            Example:
            class Supplier < ApplicationRecord
            has_one :account
            end

        3. has_many: A has_many association is similar to has_one, but indicates a one-to-many connection with another model.
            Example:
            class Author < ApplicationRecord
            has_many :books
            end

        4. has_many :through : A has_many :through association is often used to set up a many-to-many connection with another model.
            Example:
            class Physician < ApplicationRecord
            has_many :appointments
            has_many :patients, through: :appointments
            end

            class Appointment < ApplicationRecord
            belongs_to :physician
            belongs_to :patient
            end

            class Patient < ApplicationRecord
            has_many :appointments
            has_many :physicians, through: :appointments
            end

        5. has_one :through : A has_one :through association sets up a one-to-one connection with another model.
            Example:
            class Supplier < ApplicationRecord
            has_one :account
            has_one :account_history, through: :account
            end

            class Account < ApplicationRecord
            belongs_to :supplier
            has_one :account_history
            end

            class AccountHistory < ApplicationRecord
            belongs_to :account
            end

        6. has_and_belongs_to_many: A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model.
            Example:
            class Assembly < ApplicationRecord
            has_and_belongs_to_many :parts
            end

            class Part < ApplicationRecord
            has_and_belongs_to_many :assemblies
            end

            - Choosing Between has_many :through and has_and_belongs_to_many?
            The simplest rule of thumb is that you should set up a has_many :through relationship if you need to work with the relationship model as an independent entity. 
            If you don't need to do anything with the relationship model, it may be simpler to set up a has_and_belongs_to_many relationship (though you'll need to remember 
            to create the joining table in the database).

        7. Polymorphic association: A slightly more advanced twist on associations is the polymorphic association. With polymorphic associations, 
        a model can belong to more than one other model, on a single association.
            Example:
            class Picture < ApplicationRecord
            belongs_to :imageable, polymorphic: true
            end

            class Employee < ApplicationRecord
            has_many :pictures, as: :imageable
            end

            class Product < ApplicationRecord
            has_many :pictures, as: :imageable
            end

        8. Association with composite primary keys: 
            Example:
            class Author < ApplicationRecord
            self.primary_key = [:first_name, :last_name]
            has_many :books, query_constraints: [:first_name, :last_name]
            end

            class Book < ApplicationRecord
            belongs_to :author, query_constraints: [:author_first_name, :author_last_name]
            end

        9. self joins: 
            Example:    
            class Employee < ApplicationRecord
                has_many :subordinates, class_name: "Employee",
                                        foreign_key: "manager_id"

                belongs_to :manager, class_name: "Employee", optional: true
            end

        - Tips and Tricks: Here are a few things you should know to make efficient use of Active Record associations in your Rails applications:

            - Controlling caching:All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. 
                The cache is even shared across methods (@author.books.load/reload)
                But what if you want to reload the cache, because data might have been changed by some other part of the application? Just call reload on the association.
            
            - Avoiding name collisions: You are not free to use just any name for your associations. Because creating an association adds a method with that name to the model, 
                it is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. The association method would override the base method and 
                break things. For instance, attributes or connection are bad names for associations.

            - Updating the schema: You are responsible for maintaining your database schema to match your associations.eg:
                For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table.

            - Controlling association scope

            - Bi-directional associations

        - Methods Added by belongs_to: When you declare a belongs_to association, the declaring class automatically gains 8 methods related to the association:
            - association
            - association=(associate)
            - build_association(attributes = {})
            - create_association(attributes = {})
            - create_association!(attributes = {})
            - reload_association
            - reset_association
            - association_changed?
            - association_previously_changed?

         In all of these methods, association is replaced with the symbol passed as the first argument to belongs_to
         Example:
            3.0.0 :022 > @books.author
            => 
            #<Author:0x00007f0fe15e6f58
            id: 2,
            name: "Avneet",
            dob: nil,
            created_at: Thu, 30 Nov 2023 05:12:24.784698000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:12:24.784698000 UTC +00:00> 
            3.0.0 :023 > @books.author_changed?
            => false 
            3.0.0 :024 > @books.author= @author
            => 
            #<Author:0x00007f0fe1588d40
            ... 
            3.0.0 :025 > @books.author_changed?
            => true 
            3.0.0 :026 > @books.save
            TRANSACTION (0.3ms)  BEGIN
            Book Update (1.2ms)  UPDATE "books" SET "updated_at" = $1, "author_id" = $2 WHERE "books"."id" = $3  [["updated_at", "2023-11-30 07:38:08.814911"], ["author_id", 3], ["id", 4]]
            TRANSACTION (21.5ms)  COMMIT
            => true 
            3.0.0 :027 > @books.author_changed?
            => false 
            3.0.0 :028 > @books.author
            => 
            #<Author:0x00007f0fe1588d40
            id: 3,
            name: "Kunal",
            dob: nil,
            created_at: Thu, 30 Nov 2023 05:14:35.440787000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:14:35.440787000 UTC +00:00> 
            3.0.0 :029 > 
        
        - options given by belongs_to: The has_one association supports these options:
            - :autosave
            - :class_name
            - :counter_cache
            - :default
            - :dependent
            - :ensuring_owner_was
            - :foreign_key
            - :foreign_type
            - :primary_key
            - :inverse_of
            - :optional
            - :polymorphic
            - :required
            - :strict_loading
            - :touch
            - :validate

        - Scopes for belongs_to: 
            - where: The where method lets you specify the conditions that the associated object must meet.
            - includes: You can use the includes method to specify second-order associations that should be eager-loaded when this association is used.
            - readonly: If you use the readonly method, then the associated object will be read-only when retrieved via the association.
            - select: The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

        - Methods Added by has_one: When you declare a has_one association, the declaring class automatically gains 6 methods related to the association:
            - association
            - association=(associate)
            - build_association(attributes = {})
            - create_association(attributes = {})
            - create_association!(attributes = {})
            - reload_association
            - reset_association
        
         In all of these methods, association is replaced with the symbol passed as the first argument to has_one.

        - Options for has_one: The has_one association supports these options:
            - :as
            - :autosave
            - :class_name
            - :dependent
            - :disable_joins
            - :ensuring_owner_was
            - :foreign_key
            - :inverse_of
            - :primary_key
            - :query_constraints
            - :required
            - :source
            - :source_type
            - :strict_loading
            - :through
            - :touch
            - :validate
            
        - Scope for has_one:
            - where
            - includes
            - readonly
            - select

        - Methods Added by has_many: When you declare a has_many association, the declaring class automatically gains 17 methods related to the association:
            - collection: 
                3.0.0 :031 > @author.books
                Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1 /* loading for pp */ LIMIT $2  [["author_id", 3], ["LIMIT", 11]]
                => 
                [#<Book:0x00007f0fe154a018
                id: 3,
                name: "Rich Dad Poor Dad",
                genre: "Finance",
                created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                author_id: 3>,
                #<Book:0x00007f0fe1549ed8
                id: 4,
                name: "Harry Potter",
                genre: nil,
                created_at: Thu, 30 Nov 2023 06:31:21.943240000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 07:38:08.814911000 UTC +00:00,
                author_id: 3>]   

            - collection<<(object, ...): The collection<< method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model

            - collection.delete(object, ...):
                3.0.0 :037 > @author.books.delete(@books)
                TRANSACTION (0.4ms)  BEGIN
                Book Destroy (1.1ms)  DELETE FROM "books" WHERE "books"."id" = $1  [["id", 4]]
                TRANSACTION (13.0ms)  COMMIT
                => 
                [#<Book:0x00007f0fe2ca4308
                id: 4,
                name: "Harry Potter",
                genre: nil,
                created_at: Thu, 30 Nov 2023 06:31:21.943240000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 07:38:08.814911000 UTC +00:00,
                author_id: 3>]  

            - collection.destroy(object, ...): similar to delete just calls the destroy method to delete
            - collection=(objects): 
                3.0.0 :055 > @author.books=(@books)
                Book Load (0.5ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1  [["author_id", 3]]
                => 
                [#<Book:0x00007f0fe1540518
                ... 
            - collection_singular_ids
            - collection_singular_ids=(ids) : The collection_singular_ids method returns an array of the ids of the objects in the collection.
                3.0.0 :063 > @author.book_ids=3
                Book Load (0.6ms)  SELECT "books".* FROM "books" WHERE "books"."id" = $1  [["id", 3]]
                => 3 
            - collection.clear: clears the collection
            - collection.empty?: checks if the collection is empty
            - collection.size: return size of the collection
            - collection.find(...): search from cllection using id
            - collection.where(...): search using specified field.
            - collection.exists?(...): checks whether an object meeting the supplied conditions exists in the collection's table.
            - collection.build(attributes = {}): only builds new object doesnt save.
            - collection.create(attributes = {}): builds and save new object.
            - collection.create!(attributes = {}): same as above.
            - collection.reload: The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation.

        - options for has_many: The has_many association supports these options:
            - :as
            - :autosave
            - :class_name
            - :counter_cache
            - :dependent
            - :disable_joins
            - :ensuring_owner_was
            - :extend
            - :foreign_key
            - :foreign_type
            - :inverse_of
            - :primary_key
            - :query_constraints
            - :source
            - :source_type
            - :strict_loading
            - :through
            - :validate
            
        - scope for has_many: There may be times when you wish to customize the query used by has_many. Such customizations can be achieved via a scope block.
            - where
            - extending
            - group
            - includes
            - limit
            - offset
            - order
            - readonly
            - select
            - distinct

            Example:
            class Author < ApplicationRecord
                has_many :books, dependent: :destroy, -> { order "id DESC" }
            end

            Console:
            3.0.0 :085 > @author.books.all
            Book Load (0.5ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1 /* loading for pp */ LIMIT $2  [["author_id", 3], ["LIMIT", 11]]
            => 
            [#<Book:0x00007f0fe1587e40
            id: 7,
            name: "Lolita",
            genre: nil,
            created_at: Thu, 30 Nov 2023 10:31:05.724079000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 10:31:05.724079000 UTC +00:00,
            author_id: 3>,
            #<Book:0x00007f0fe1587d00
            id: 3,
            name: "Rich Dad Poor Dad",
            genre: "Finance",
            created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
            author_id: 3>]

        -
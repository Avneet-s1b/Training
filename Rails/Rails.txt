            **** Rails ****


    1. Rails is an open source web framework that uses ruby programming language.

    2. Framework vs Library:  libraries target a specific functionality, while a framework tries to provide everything required to develop a complete application.

    3. Major principles of rails: - DRY (Don't Repeat Yourself) : Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
                                  - Rails has opinions about the best way to do many things in a web application, and defaults to this set of conventions, rather than require that you specify minutiae through endless configuration files.

    4. MVC Architecture: MVC stands for Model View Controller Architecture. It helps in ensuring DRY principal is followed.

        - Model: Contains all the database related objects and business logic
        - View: Contains all the objects that will be shown to the user like html css js.
        - Controller: Contains all the code that will help in decision making process for a given request

        Working:
        - Request from browser will be sent too Controller for decision making
        - Controller will then ask the result of request from model which will be connected to the db 
        - then after recieving the result controller will show results to user using the View object.

    5. Create a new project: Command: rails new <application-name>

        To start the server : rails server

        by default this project is using sqlite3 db

        when we have to create a project using postgres as db command is:

        rails new <application-name> -d postgresql

        before starting the server we have to initialize the db which is done using the command:

        rake db:create

        then start the server using: rails server

    6. Most of the coding is done in the app folder(95%) followed by config dir, gem file(packages used by our project) and db dir(database related files like db migration).

    7. We have different files for production,development,test environment inside the config dir.

    8. Generate controller: Command : rails generate controller Demo[Controller-name] index[List of views]
        
        this command will generate a new controller in the controller folder of app and also a view inside view folder (demo/index)
        also in the config file we will have a route created in routes.rb file showing that demo controller is associated with index view

    9. Rails Architecture(MVC arch explained wrt reality): Browser sends request using a web server(eg: apache) to the application.
        Now application before sending the req to rail framework checks that whether the asked path is present insdie the public folder or not.
        if it is present then the req is returned through public folder only and if it is not then the req is sent to the rails framework.

        Any file inside public folder is visible for users.

    10. Routing: It helps in determining which controller to be called according to the request.
        In short helps in determining the routes. routes.rb has all the routes which is present in the config folder

        Types of routes:
            -simple match route
            -default route
            -root route
            -resourceful routes

        Simple match route: Syntax: get "demo/index"
                                    or
                                    match "demo/index", :to => "demo#index", :via => :get (this is useful when we have to keep diff path name than controller name and view name)

        Default route: Syntax: get ":controller(/:action(/:id))"
                               or
                               match ':controller(/:action(/:id))', :via => :get

        root route: Syntax: root "demo#index"
                            or
                            match "/", :to => "demo#index", :via => :get

    11. Rendering templates: the routes defined help in deciding the controller and action(method in controller).
        and then the template is rendered using default behaviour as Controller name as folder and action name as filename to choose the template.

        to render according to our own wish we may use render("path") inside the action
        Example:
            class DemoController < ApplicationController
            layout false

            def index
                render('demo/hello')
            end

            def hello
                render('demo/index')
            end
            end

    12. Redirect: When we recieve a request and controller instead of sending view as a response sends request to another controller 
        for eg: trying to access a page that rquires login without loggin in that will send user to login screen first

        Redirect changes the url link.    

        Example:
        class DemoController < ApplicationController
        def index
        end

        def hello
            redirect_to(controller:"demo",action:"index")
        end
        end

        hello action will redirect to index everytime

        We can also write : redirect_to(action:"index")
        if the controller is same

    13. What is erb?: Embedded ruby(used to write ruby code in html file)

        Syntax: <% code %> (it doesnot outputs the result on template)
                or
                <%= code %> (it outputs the result)

        Example:
        <h1>Index page</h1>

        <%= "printss 1" %>

        <br />

        <% set = "Hello" %>

        <%= "Hello #{set}" %>

        <% 3.times do |n| %>
            <p><%= n %></p>
        <% end %>

        Output:
        Index page
        printss 1
        Hello Hello
        0

        1

        2

    14. instance variables: start with @ and can be shared by the class and belong to one instance of the class
        Can be used in the templates(views)
        Example:
        <% @array.each do |n| %>
            <p><%= n %></p>
        <% end %>

    15. Links: use to navigate to another webpage. similar to anchor tag in html
        Syntax: <%= link_to("display name of link","path") %>
                or
                <%= link_to("display name of link",{:controller => name , :action => name}) %>

        Example:
        <h1>hello page</h1>

        <a href = "/demo/index"> index page 1</a>

        <br /> <br />

        <%= link_to("Index page 2",{:action => "index"}) %>

    16. URL Parameters: parameters are usually content that appears in the link after '?'
        params are stored in rails frame work in 'params' variable.

        Exmple:
        hello.html.erb file

        <%= link_to("Index page 2",{:action => "index" , :id => 30 , :page =>444}) %>

        index.html.erb file

        ID: <%= params['id'] %> 
        Page: <%= @page %>

        controller file

        class DemoController < ApplicationController
        def index
            @array = [1,2,3,4,5]
            @page = params['page']
        end

        def hello
            
            #redirect_to(controller:"demo",action:"index")
        end
        end

        We can access parameters from params var both by 'str' and :str way. and these params are stored as strings in rails

    17. Autoloading: Application classes and modules are available everywhere, you do not need and should not load anything under app with require. 
            require "application_controller" # DON'T DO THIS.

    18. Model: A model is a Ruby class that is used to represent data. Additionally, models can interact with the application's database 
            through a feature of Rails called Active Record.

                - Generating a model: Syntax: bin/rails generate model Article(model_name) title:string body:text(attributes)

                out of the created files we work in two files one is migrate file which contains the description of the table created
                other one is inside the model which is used for validations 

                - Migrating a model: Migrations are used to alter the structure of an application's database.
                With migration we can interact with our database/table through our model in console no need to write sql.

                Syntax: rails db:migrate

                - interacting with db: We have to open console using command: bin/rails console

                    1. new: To create new record  
                        Eg: article = Article.new(title: "Hello Rails", body: "I am on Rails!")

                    2. save: new will only create new record to save the record in table in db we have to use save method
                        Eg: article.save

                    3. create: it creates a new entry as well ass adds it to the table.

                    4. find: finds specific id from table.
                        Eg: Article.find(1)

                    5. all: List all records in the table
                        Eg: Article.all


    19. Showing table in templates: We can do this by calling the model class in our controller as
            
            class DemoController < ApplicationController
            def index
                @arr = Demo.all
            end
            end

        Then calling this instance var in view file using erb format as:
            
            <% @arr.each do |rec| %>
                <p><%= rec[:name] %></p>
            <% end %>

    20. Resourceful Routing: Rails provides a routes method named resources that maps all of the conventional routes 
    for a collection of resources, such as articles.

        Syntax:
        Rails.application.routes.draw do
        # get 'demo/index'
        resources :demo
        # match 'demo/:id', :to => 'demo#show', :via => :get
        # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

        # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
        # Can be used by load balancers and uptime monitors to verify that the app is live.
        get "up" => "rails/health#show", as: :rails_health_check

        # Defines the root path route ("/")
        # root "posts#index"
        end

    We can inspect what routes are mapped by running the bin/rails routes command:
        bin/rails routes
            Prefix Verb   URI Pattern                  Controller#Action
                root GET    /                            articles#index
            articles GET    /articles(.:format)          articles#index
        new_article GET    /articles/new(.:format)      articles#new
            article GET    /articles/:id(.:format)      articles#show
                    POST   /articles(.:format)          articles#create
        edit_article GET    /articles/:id/edit(.:format) articles#edit
                    PATCH  /articles/:id(.:format)      articles#update
                    DELETE /articles/:id(.:format)      articles#destroy

    21. Active Record: Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. 
    Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database. basically helps in db creation migration etc.

        - ORM: Object Relational Mapping, commonly referred to as its abbreviation ORM.
            Using ORM, the properties and relationships of the objects in an application can be easily stored and retrieved from a database without writing SQL statements 
            directly and with less overall database access code.

        - Convention over configuration:
            1. naming convention: model name singular(Article,person) , table name plural(Articles,people)
            2. schema conventions: Foreign keys - These fields should be named following the pattern singularized_table_name_id (e.g., item_id, order_id). 
            These are the fields that Active Record will look for when you create associations between your models.
            Primary keys - By default, Active Record will use an integer column named id as the table's primary key

        - Application record: When generating an application, an abstract ApplicationRecord class will be created in app/models/application_record.rb. 
        This is the base class for all models in an app, and it's what turns a regular ruby class into an Active Record model. When we create a model it automatically inherits from ApplicationRecord

        Creating a model and creating an active record model is same.

        - Overriding naming conventions: Since ApplicationRecord inherits from ActiveRecord::Base, your application's models will have a number of helpful methods available to them. 
        For example, you can use the ActiveRecord::Base.table_name= method to customize the table name that should be used:
        Example:
        class Product < ApplicationRecord
        self.table_name = "my_products"
        end

        If you do so, you will have to manually define the class name that is hosting the fixtures (my_products.yml) using the set_fixture_class method in your test definition:

    22. CRUD: CREATE READ UPDATE DELETE

        -Create: user = User.create(name: "David", occupation: "Code Artist")
                 or
                 user = User.new
                 user.save

        -Read:  users = User.all
                or
                user = User.first
                or
                david = User.find_by(name: 'David')
                or
                users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)

        -Update: user = User.find_by(name: 'David')
                 user.update(name: 'Dave')
                 or
                 User.update_all attribute:val 

        -Delete:user = User.find_by(name: 'David')
                user.destroy
                or
                User.destroy_by(name: 'David')
                User.destroy_all

            
    23. Migration: Migrations are a convenient way to alter your database schema over time in a consistent way. 
    They use a Ruby DSL so that you don't have to write SQL by hand, allowing your schema and changes to be database independent.

        -Migrations are stored as files in the db/migrate directory, one for each migration class. 
        The name of the file is of the form YYYYMMDDHHMMSS_create_products.rb

        - Generating a migration: bin/rails generate migration AddDetailsToProducts name:string age:string

        - Removing a column from table: bin/rails generate migration RemovePartNumberFromProducts part_number:string

        - Create a table: bin/rails generate migration CreateProducts name:string part_number:string

            Not recommend this instead use generate model to create a new table

        - Add Foriegn Key to a table: bin/rails generate migration AddUserRefToProducts user:references

            Adds user_id col to Products which is a Fk for this table and pk from user table.

        - db folder: Migrate folder is present here which is responsible for every change in db. Every altercation in db we have to create a new migration old ones cant be migrated again.

        - Writing migrations: We can edit the migrations file before migrating it and reflecting it in our dbs.

        - Composite primary keys: we can add composite pk to a table by adding :primary_key option to the create table method in change method 
            Example:
            class CreateProducts < ActiveRecord::Migration[7.1]
            def change
                create_table :products, primary_key: [:customer_id, :product_sku] do |t|
                t.integer :customer_id
                t.string :product_sku
                t.text :description
                end
            end
            end

        - Sometimes helpers are not enough that are provided bu active records to edit the database so we can 
        execute sql queries to in the console using special method.([Class].connection.execute)

            Example: Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1") 

        - revert migration: We can revert any migration by creating new migration and using revert functionality.

            Example:
            require_relative "20231123110831_add_product_ref_to_customers"

            class RevertAddProductRef < ActiveRecord::Migration[7.1]
              def change
                revert AddProductRefToCustomers
              end
            end

        - run a specific migration : bin/rails db:migrate VERSION=20080906120000

        - rollback: bin/rails db:rollback STEP=3

            if needed to rollback to only 1 step then remove STEP=3

        - redo: The db:migrate:redo command is a shortcut for doing a rollback and then migrating back up again

        - setup db: The bin/rails db:setup command will create the database, load the schema, and initialize it with the seed data.

        - prepare: The bin/rails db:prepare command is similar to bin/rails db:setup, but it operates idempotently.

        - reset: The bin/rails db:reset command will drop the database and set it up again. This is functionally equivalent to bin/rails db:drop db:setup.

        - run migration in different environments: bin/rails db:migrate RAILS_ENV=test

            by default it runs in development environment
        
        - check status of migrations: bin/rails db:migrate:status

    24. Validations: Validations are used to ensure that only valid data is saved into your database.

        - The following methods trigger validations, and will save the object to the database only if the object is valid:
            - create
            - create!
            - save
            - save!
            - update
            - update!

        - The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.
            - decrement!
            - decrement_counter
            - increment!
            - increment_counter
            - insert
            - insert!
            - insert_all
            - insert_all! 
            - etc
        
        - valid? : to check the validity of the record to be entered
            irb> Person.create(name: "John Doe").valid?
            => true
            irb> Person.create(name: nil).valid?
            => false

        - Note that an object instantiated with new will not report errors even if it's technically invalid, because validations are automatically run only when the object is saved,
         such as with the create or save methods.

        - acceptance: used in checkbox to check that value is checked or not.

        - comparison: used to compare two attributes.
            Example: validates :end, comparison: { greater_than: :start }

        - confirmation: to check that two values entered are equal or not like re enter password situation.

        - format:  validates the attributes' values by testing whether they match a given regular expression.

        - inclusion: only allows value in the list.

        - exclusion: inclusion!

        - length: decide the length of the record to be entered.

        - numericality: to ensure only valid numbers are entered.

        - presence: value cannot be nil.

        - absence: presence!

        - uniqueness

    
    25. Options in Validation: 
        - :allow_nil: Skip validation if the attribute is nil.
        
        - :allow_blank: Skip validation if the attribute is blank.
        
        - :message: Specify a custom error message.
        
        - :on: Specify the contexts where this validation is active.

        - :strict: Raise an exception when the validation fails.
        Example:
        class Person < ApplicationRecord
        validates :name, presence: { strict: true }
        end

        irb> Person.new.valid?
        ActiveModel::StrictValidationFailed: Name can't be blank

    26. Conditional Validation: Sometimes it will make sense to validate an object only when a given predicate is satisfied. 
    You can do that by using the :if and :unless option.

        - Using a Symbol with :if and :unless:

            Example:
            validates :adhar_number, presence: true, if: :mobile_pres

            def mobile_pres
                mobile.empty? == false
            end
            
            op:
            3.0.0 :074 > c.errors.objects.first.full_message
            => "Adhar number can't be blank" 

        - Using a Proc with :if and :unless

            Example:
            validates :adhar_number, presence: true, unless: Proc.new{|obj| obj.mobile.empty?}

            op:
            3.0.0 :088 > c = Customer.new(name:"Ishita",mobile:"9971")
            => 
            #<Customer:0x00007f2837561740
            ... 
            3.0.0 :089 > c.valid?
            => false

        - Grouping Conditional Validations: Sometimes it is useful to have multiple validations use one condition. It can be easily achieved using with_options.

            Example:

            class User < ApplicationRecord
            with_options if: :is_admin? do |admin|
                admin.validates :password, length: { minimum: 10 }
                admin.validates :email, presence: true
            end
            end

        - Combining Validation Conditions: On the other hand, when multiple conditions define whether or not a validation should happen, an Array can be used. Moreover, you can apply both :if and :unless to the same validation.

            Example:
            class Computer < ApplicationRecord
            validates :mouse, presence: true, if: [Proc.new { |c| c.market.retail? }, :desktop?], unless: Proc.new { |c| c.trackpad.present? }

    27. Custom Validators: Custom validators are classes that inherit from ActiveModel::Validator. These classes must implement the validate method which takes a record as an argument and performs the validation on it.

        Example:
        class MyValidator < ActiveModel::Validator
            def validate(record)
                unless record.name.start_with? 'X'
                    record.errors.add :name, "Provide a name starting with X, please!"
                end
            end
        end

        class Customer < ApplicationRecord

            validates_with MyValidator
        end

    28. Cutom methods: You can also create methods that verify the state of your models and add errors to the errors collection when they are invalid. You must then register these methods by using the validate class

        Example:
        class Invoice < ApplicationRecord
        validate :expiration_date_cannot_be_in_the_past,
            :discount_cannot_be_greater_than_total_value

        def expiration_date_cannot_be_in_the_past
            if expiration_date.present? && expiration_date < Date.today
            errors.add(:expiration_date, "can't be in the past")
            end
        end

        def discount_cannot_be_greater_than_total_value
            if discount > total_value
            errors.add(:discount, "can't be greater than total value")
            end
        end
        end

        - If you want to find out all of the validators for a given objects, look no further than validators.
            - Customer.validators
             => [#<MyValidator:0x00007f2492327b58 @options={}>] 

    29. Errors: 
        - errors: 3.0.0 :028 > c.errors
                 => #<ActiveModel::Errors [#<ActiveModel::Error attribute=name, type=blank, options={:message=>"name cant be empty"}>]> 

                3.0.0 :029 > c.errors.full_messages
                => ["Name name cant be empty"] 

                3.0.0 :030 > c.errors.first.details
                => {:error=>:blank}

        - errors[]: 3.0.0 :031 > c.errors[:name]
                     => ["name cant be empty"] 

        - where: where returns an array of error objects filtered by various degrees of conditions
                3.0.0 :032 > error = c.errors.where(:name).last
                => #<ActiveModel::Error attribute=name, type=blank, options={:message=>"name cant be empty"}> 
                3.0.0 :033 > error.message
                => "name cant be empty" 
                3.0.0 :034 > error.full_message
                => "Name name cant be empty" 

        - add: The add method creates the error object by taking the attribute, the error type and additional options hash. 
                class Person < ApplicationRecord
                validate do |person|
                    errors.add :name, :too_plain, message: "is not cool enough"
                end
                end

                3.0.0 :043 > c.errors.full_messages
                => ["Name name cant be empty", "Name is not cool enough"] 

        - size & clear: The clear method is used when you intentionally want to clear the errors collection. 
        Of course, calling errors.clear upon an invalid object won't actually make it valid: the errors collection will now be empty, 
        but the next time you call valid? or any method that tries to save this object to the database, the validations will run again. 
        If any of the validations fail, the errors collection will be filled again.

                3.0.0 :051 > c.errors.size
                => 2 
                3.0.0 :052 > c.errors.clear
                => [] 
                3.0.0 :053 > c.errors.size
                => 0 

        
    30. Callbacks: Callbacks are methods that get called at certain moments of an object's life cycle. 
    With callbacks it is possible to write code that will run whenever an Active Record object is created, saved, updated, deleted, validated, or loaded from the database.

        Example:
        class Baby < ApplicationRecord
        after_create -> { puts "Congratulations!" }
        end

        irb> @baby = Baby.create
        Congratulations!

        - Callbacks Registration: In order to use the available callbacks, you need to register them. 
        You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks
        
        Example:
            after_create :creation

            private
                def creation
                    puts "Product added successfully"            
                end

        - available callbacks:
            1. Creating an Object
                before_validation
                after_validation
                before_save
                around_save
                before_create
                around_create
                after_create
                after_save
                after_commit / after_rollback

            2. Updating an Object
                before_validation
                after_validation
                before_save
                around_save
                before_update
                around_update
                after_update
                after_save
                after_commit / after_rollback

            3. Destroying an Object
                before_destroy
                around_destroy
                after_destroy
                after_commit / after_rollback

            4. after_initialize
            
            5. after_find

            6. after_touch

        - Methods that trigger callbacks: The following methods trigger callbacks:
            create
            create!
            destroy
            destroy!
            destroy_all
            destroy_by
            save
            save!
            save(validate: false)
            toggle!
            touch
            update_attribute
            update
            update!
            valid?
            
            Additionally, the after_find callback is triggered by the following finder methods:
            all
            first
            find
            find_by
            find_by_*
            find_by_*!
            find_by_sql
            last

            The after_initialize callback is triggered every time a new object of the class is initialized.

        - Skipping Callbacks: Just as with validations, it is also possible to skip callbacks by using the following methods:
            decrement!
            decrement_counter
            delete
            delete_all
            delete_by
            increment!
            increment_counter
            insert
            insert!
            insert_all
            insert_all!
            touch_all
            update_column
            update_columns
            update_all
            update_counters
            upsert
            upsert_all

    31. Throw errors: if error is thrown then the queue having validations and callbacks is rolled back.

    32. Conditional callbacks: As with validations, we can also make the calling of a callback method conditional on the satisfaction of a given predicate. 
    We can do this using the :if and :unless options, which can take a symbol, a Proc or an Array.

        - if and unless with a proc:
            Example:
            before_create :fn , if: Proc.new { name.length==6 }
            def fn 
                puts "word is of length #{name}"
            end

        TO ACCESS ATTRIBUTE BEIGN GIVEN WE CAN SIMPLY DO IT USING ATTRIBUTE NAME LIKE ABOVE WE HAVE FOUND LENGTH OF NAME BEIGN ENTERED BY THE USER.

        - if and unless with a :function in place of proc

        - multiple conditions can be entered like if: [cond1,cond2]

        - if and unless can be used together too.

    
    33. Callback classes: Sometimes the callback methods that you'll write will be useful enough to be reused by other models. 
    Active Record makes it possible to create classes that encapsulate the callback methods, so they can be reused.

        Example:
        class OurCallbackClass
            def before_create(record)
                if record.name.length>2
                    puts "length is greater than 2"
                end
            end
        end

        class Product < ApplicationRecord
            before_create OurCallbackClass.new
        end

    34. Associations: In Rails, an association is a connection between two Active Record models. 
        
        - They make common operations simpler and easier in your code.In Rails, an association is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code.

        Example:
        Create two table author and books and add reference between them using migration
        class AddAuthRefToBooks < ActiveRecord::Migration[7.1]
        def change
            add_reference :books, :author, null: false, foreign_key: true
        end
        end

        in model folder specify the type of relation to perform operations on both models simultaeously and easily.

        class Author < ApplicationRecord
        has_many :books, dependent: :destroy
        end

        class Book < ApplicationRecord
        belongs_to :author
        end

        - Types of association:
        
        1. belongs_to: A belongs_to association sets up a connection with another model, such that each instance of the declaring model "belongs to" one instance of the other model.
            Example:
            class Book < ApplicationRecord
            belongs_to :author
            end

        2. has_one: A has_one association indicates that one other model has a reference to this model.
            Example:
            class Supplier < ApplicationRecord
            has_one :account
            end

        3. has_many: A has_many association is similar to has_one, but indicates a one-to-many connection with another model.
            Example:
            class Author < ApplicationRecord
            has_many :books
            end

        4. has_many :through : A has_many :through association is often used to set up a many-to-many connection with another model.
            Example:
            class Physician < ApplicationRecord
            has_many :appointments
            has_many :patients, through: :appointments
            end

            class Appointment < ApplicationRecord
            belongs_to :physician
            belongs_to :patient
            end

            class Patient < ApplicationRecord
            has_many :appointments
            has_many :physicians, through: :appointments
            end

        5. has_one :through : A has_one :through association sets up a one-to-one connection with another model.
            Example:
            class Supplier < ApplicationRecord
            has_one :account
            has_one :account_history, through: :account
            end

            class Account < ApplicationRecord
            belongs_to :supplier
            has_one :account_history
            end

            class AccountHistory < ApplicationRecord
            belongs_to :account
            end

        6. has_and_belongs_to_many: A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model.
            Example:
            class Assembly < ApplicationRecord
            has_and_belongs_to_many :parts
            end

            class Part < ApplicationRecord
            has_and_belongs_to_many :assemblies
            end

            - Choosing Between has_many :through and has_and_belongs_to_many?
            The simplest rule of thumb is that you should set up a has_many :through relationship if you need to work with the relationship model as an independent entity. 
            If you don't need to do anything with the relationship model, it may be simpler to set up a has_and_belongs_to_many relationship (though you'll need to remember 
            to create the joining table in the database).

        7. Polymorphic association: A slightly more advanced twist on associations is the polymorphic association. With polymorphic associations, 
        a model can belong to more than one other model, on a single association.
            Example:
            class Picture < ApplicationRecord
            belongs_to :imageable, polymorphic: true
            end

            class Employee < ApplicationRecord
            has_many :pictures, as: :imageable
            end

            class Product < ApplicationRecord
            has_many :pictures, as: :imageable
            end

        8. Association with composite primary keys: 
            Example:
            class Author < ApplicationRecord
            self.primary_key = [:first_name, :last_name]
            has_many :books, query_constraints: [:first_name, :last_name]
            end

            class Book < ApplicationRecord
            belongs_to :author, query_constraints: [:author_first_name, :author_last_name]
            end

        9. self joins: 
            Example:    
            class Employee < ApplicationRecord
                has_many :subordinates, class_name: "Employee",
                                        foreign_key: "manager_id"

                belongs_to :manager, class_name: "Employee", optional: true
            end

        - Tips and Tricks: Here are a few things you should know to make efficient use of Active Record associations in your Rails applications:

            - Controlling caching:All of the association methods are built around caching, which keeps the result of the most recent query available for further operations. 
                The cache is even shared across methods (@author.books.load/reload)
                But what if you want to reload the cache, because data might have been changed by some other part of the application? Just call reload on the association.
            
            - Avoiding name collisions: You are not free to use just any name for your associations. Because creating an association adds a method with that name to the model, 
                it is a bad idea to give an association a name that is already used for an instance method of ActiveRecord::Base. The association method would override the base method and 
                break things. For instance, attributes or connection are bad names for associations.

            - Updating the schema: You are responsible for maintaining your database schema to match your associations.eg:
                For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table.

            - Controlling association scope

            - Bi-directional associations

        - Methods Added by belongs_to: When you declare a belongs_to association, the declaring class automatically gains 8 methods related to the association:
            - association
            - association=(associate)
            - build_association(attributes = {})
            - create_association(attributes = {})
            - create_association!(attributes = {})
            - reload_association
            - reset_association
            - association_changed?
            - association_previously_changed?

         In all of these methods, association is replaced with the symbol passed as the first argument to belongs_to
         Example:
            3.0.0 :022 > @books.author
            => 
            #<Author:0x00007f0fe15e6f58
            id: 2,
            name: "Avneet",
            dob: nil,
            created_at: Thu, 30 Nov 2023 05:12:24.784698000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:12:24.784698000 UTC +00:00> 
            3.0.0 :023 > @books.author_changed?
            => false 
            3.0.0 :024 > @books.author= @author
            => 
            #<Author:0x00007f0fe1588d40
            ... 
            3.0.0 :025 > @books.author_changed?
            => true 
            3.0.0 :026 > @books.save
            TRANSACTION (0.3ms)  BEGIN
            Book Update (1.2ms)  UPDATE "books" SET "updated_at" = $1, "author_id" = $2 WHERE "books"."id" = $3  [["updated_at", "2023-11-30 07:38:08.814911"], ["author_id", 3], ["id", 4]]
            TRANSACTION (21.5ms)  COMMIT
            => true 
            3.0.0 :027 > @books.author_changed?
            => false 
            3.0.0 :028 > @books.author
            => 
            #<Author:0x00007f0fe1588d40
            id: 3,
            name: "Kunal",
            dob: nil,
            created_at: Thu, 30 Nov 2023 05:14:35.440787000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:14:35.440787000 UTC +00:00> 
            3.0.0 :029 > 
        
        - options given by belongs_to: The has_one association supports these options:
            - :autosave
            - :class_name
            - :counter_cache
            - :default
            - :dependent
            - :ensuring_owner_was
            - :foreign_key
            - :foreign_type
            - :primary_key
            - :inverse_of
            - :optional
            - :polymorphic
            - :required
            - :strict_loading
            - :touch
            - :validate

        - Scopes for belongs_to: 
            - where: The where method lets you specify the conditions that the associated object must meet.
            - includes: You can use the includes method to specify second-order associations that should be eager-loaded when this association is used.
            - readonly: If you use the readonly method, then the associated object will be read-only when retrieved via the association.
            - select: The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

        - Methods Added by has_one: When you declare a has_one association, the declaring class automatically gains 6 methods related to the association:
            - association
            - association=(associate)
            - build_association(attributes = {})
            - create_association(attributes = {})
            - create_association!(attributes = {})
            - reload_association
            - reset_association
        
         In all of these methods, association is replaced with the symbol passed as the first argument to has_one.

        - Options for has_one: The has_one association supports these options:
            - :as
            - :autosave
            - :class_name
            - :dependent
            - :disable_joins
            - :ensuring_owner_was
            - :foreign_key
            - :inverse_of
            - :primary_key
            - :query_constraints
            - :required
            - :source
            - :source_type
            - :strict_loading
            - :through
            - :touch
            - :validate
            
        - Scope for has_one:
            - where
            - includes
            - readonly
            - select

        - Methods Added by has_many: When you declare a has_many association, the declaring class automatically gains 17 methods related to the association:
            - collection: 
                3.0.0 :031 > @author.books
                Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1 /* loading for pp */ LIMIT $2  [["author_id", 3], ["LIMIT", 11]]
                => 
                [#<Book:0x00007f0fe154a018
                id: 3,
                name: "Rich Dad Poor Dad",
                genre: "Finance",
                created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                author_id: 3>,
                #<Book:0x00007f0fe1549ed8
                id: 4,
                name: "Harry Potter",
                genre: nil,
                created_at: Thu, 30 Nov 2023 06:31:21.943240000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 07:38:08.814911000 UTC +00:00,
                author_id: 3>]   

            - collection<<(object, ...): The collection<< method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model

            - collection.delete(object, ...):
                3.0.0 :037 > @author.books.delete(@books)
                TRANSACTION (0.4ms)  BEGIN
                Book Destroy (1.1ms)  DELETE FROM "books" WHERE "books"."id" = $1  [["id", 4]]
                TRANSACTION (13.0ms)  COMMIT
                => 
                [#<Book:0x00007f0fe2ca4308
                id: 4,
                name: "Harry Potter",
                genre: nil,
                created_at: Thu, 30 Nov 2023 06:31:21.943240000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 07:38:08.814911000 UTC +00:00,
                author_id: 3>]  

            - collection.destroy(object, ...): similar to delete just calls the destroy method to delete
            - collection=(objects): 
                3.0.0 :055 > @author.books=(@books)
                Book Load (0.5ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1  [["author_id", 3]]
                => 
                [#<Book:0x00007f0fe1540518
                ... 
            - collection_singular_ids
            - collection_singular_ids=(ids) : The collection_singular_ids method returns an array of the ids of the objects in the collection.
                3.0.0 :063 > @author.book_ids=3
                Book Load (0.6ms)  SELECT "books".* FROM "books" WHERE "books"."id" = $1  [["id", 3]]
                => 3 
            - collection.clear: clears the collection
            - collection.empty?: checks if the collection is empty
            - collection.size: return size of the collection
            - collection.find(...): search from cllection using id
            - collection.where(...): search using specified field.
            - collection.exists?(...): checks whether an object meeting the supplied conditions exists in the collection's table.
            - collection.build(attributes = {}): only builds new object doesnt save.
            - collection.create(attributes = {}): builds and save new object.
            - collection.create!(attributes = {}): same as above.
            - collection.reload: The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation.

        - options for has_many: The has_many association supports these options:
            - :as
            - :autosave
            - :class_name
            - :counter_cache
            - :dependent
            - :disable_joins
            - :ensuring_owner_was
            - :extend
            - :foreign_key
            - :foreign_type
            - :inverse_of
            - :primary_key
            - :query_constraints
            - :source
            - :source_type
            - :strict_loading
            - :through
            - :validate
            
        - scope for has_many: There may be times when you wish to customize the query used by has_many. Such customizations can be achieved via a scope block.
            - where
            - extending
            - group
            - includes
            - limit
            - offset
            - order
            - readonly
            - select
            - distinct

            Example:
            class Author < ApplicationRecord
                has_many :books, dependent: :destroy, -> { order "id DESC" }
            end

            Console:
            3.0.0 :085 > @author.books.all
            Book Load (0.5ms)  SELECT "books".* FROM "books" WHERE "books"."author_id" = $1 /* loading for pp */ LIMIT $2  [["author_id", 3], ["LIMIT", 11]]
            => 
            [#<Book:0x00007f0fe1587e40
            id: 7,
            name: "Lolita",
            genre: nil,
            created_at: Thu, 30 Nov 2023 10:31:05.724079000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 10:31:05.724079000 UTC +00:00,
            author_id: 3>,
            #<Book:0x00007f0fe1587d00
            id: 3,
            name: "Rich Dad Poor Dad",
            genre: "Finance",
            created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
            author_id: 3>]

        - has_and_belongs_to_many has same methods, options and scope as has_many.

        -Association Calbacks: Association callbacks are similar to normal callbacks, but they are triggered by events in the life cycle of a collection. There are four available association callbacks:
            - before_add
            - after_add
            - before_remove
            - after_remove

            Example:
            class Author < ApplicationRecord
                has_many :books, before_add: :check_credit_limit

                def check_credit_limit(book)
                    puts "Adds a booooooooook!"
                end


            end

            Console:
            3.0.0 :024 > @b = @a.books.create(name:"Book D")
            Adds a booooooooook!
            TRANSACTION (0.2ms)  BEGIN
            Book Create (2.0ms)  INSERT INTO "books" ("name", "genre", "created_at", "updated_at", "author_id") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["name", "Book D"], ["genre", nil], ["created_at", "2023-11-30 11:52:53.266127"], ["updated_at", "2023-11-30 11:52:53.266127"], ["author_id", 3]]
            TRANSACTION (13.2ms)  COMMIT
            => 
            #<Book:0x00007f6e67dba4e8
            ... 

        
        - Single Table Inheritance: it creates a main parent table with many child tables inheriting from it but the data is stored only in the parent table with type(child name) also in that parent table in front of the record.
            
            Command: bin/rails generate model vehicle type:string color:string price:integer 
            Above command creates the parent model

                  bin/rails generate model car --parent=Vehicle
            Above command creates the child table.

            Models:
            class Vehicle < ApplicationRecord
            end

            class Car < Vehicle
            end

            Console: 
            3.0.0 :001 > Car.create(color:"Red",price:800000)
            TRANSACTION (0.2ms)  BEGIN
            Car Create (1.5ms)  INSERT INTO "vehicles" ("type", "color", "price", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["type", "Car"], ["color", "Red"], ["price", 800000], ["created_at", "2023-11-30 12:02:40.747055"], ["updated_at", "2023-11-30 12:02:40.747055"]]
            TRANSACTION (21.6ms)  COMMIT
            => 
            #<Car:0x00007f8ae471bd50
            id: 1,
            type: "Car",
            color: "Red",
            price: 800000,
            created_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00> 
            3.0.0 :002 > Car.all
            Car Load (0.4ms)  SELECT "vehicles".* FROM "vehicles" WHERE "vehicles"."type" = $1 /* loading for pp */ LIMIT $2  [["type", "Car"], ["LIMIT", 11]]
            => 
            [#<Car:0x00007f8ae5bac300
            id: 1,
            type: "Car",
            color: "Red",
            price: 800000,
            created_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00>] 
            3.0.0 :003 > Vehicle.all
            Vehicle Load (0.2ms)  SELECT "vehicles".* FROM "vehicles" /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
            => 
            [#<Car:0x00007f8add8da788
            id: 1,
            type: "Car",
            color: "Red",
            price: 800000,
            created_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 12:02:40.747055000 UTC +00:00>] 
            
        - Delegated Types: The disadvantage of this approach is that it results in bloat to that table. Since 
         it will even include attributes specific to a subclass that aren't used by anything else.

         Delegated types solves this problem, via delegated_type.
            In order to use delegated types, we have to model our data in a particular way. The requirements are as follows:
            - There is a superclass that stores shared attributes among all subclasses in it's table.
            - Each subclass must inherit from the super class, and will have a separate table for any additional attributes specific to it.

            Creating new models:
                bin/rails generate model entry entryable_type:string entryable_id:integer
                bin/rails generate model message subject:string body:string
                bin/rails generate model comment content:string

                class Entry < ApplicationRecord
                delegated_type :entryable, types: %w[ Message Comment ], dependent: :destroy
                end

            Create a module for subclasses:
                module Entryable
                extend ActiveSupport::Concern

                included do
                    has_one :entry, as: :entryable, touch: true
                end
                end

            Add module to subclasses:
                class Message < ApplicationRecord
                include Entryable
                end

                class Comment < ApplicationRecord
                include Entryable
                end

            Creating an object:
                Entry.create! entryable: Message.new(subject: "hello!")

    
    35. Active record Query interface: Active Record insulates you from the need to use SQL in most cases.
        Active Record will perform queries on the database for you and is compatible with most database systems.

        1. Retrieving a Single Object:
            1.1- Find: To find one id
                Book.find(13)
                op:
                Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."id" = $1 LIMIT $2  [["id", 13], ["LIMIT", 1]]
                => 
                #<Book:0x00007fb637f16f40
                id: 13,
                name: "Book D",
                genre: nil,
                created_at: Thu, 30 Nov 2023 11:52:53.266127000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 11:52:53.266127000 UTC +00:00,
                author_id: 3>

                To find multiple ids: Book.find([12,13])
                To find using composite primary key: Model.find([id1,id2])

            1.2- Take: The take method retrieves a record without any implicit ordering.
                    
                    Book.take

                    Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT $1  [["LIMIT", 1]]
                    => 
                    #<Book:0x00007fb637f1ca80
                    id: 3,
                    name: "Rich Dad Poor Dad",
                    genre: "Finance",
                    created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                    updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                    author_id: 3>

                    We can also do: Book.take(3) to take 3 records.

            1.3- first: to take first 1 or more records.

                Book.first
                op:
                Book Load (0.3ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT $1  [["LIMIT", 1]]
                => 
                #<Book:0x00007fb637f15500
                id: 3,
                name: "Rich Dad Poor Dad",
                genre: "Finance",
                created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
                author_id: 3> 

                We can also do: Book.first(3) to take first 3 records.

            1.4- last: to take last 1 or more records.

            1.5- order: orders on specific parameter.

                3.0.0 :013 > Book.order(:name)

            1.6- find_by: 3.0.0 :017 > Book.find_by(name:"The Great Gatsby")
                op:
                Book Load (0.5ms)  SELECT "books".* FROM "books" WHERE "books"."name" = $1 LIMIT $2  [["name", "The Great Gatsby"], ["LIMIT", 1]]
                => 
                #<Book:0x00007fb62b848350
                id: 6,
                name: "The Great Gatsby",
                genre: nil,
                created_at: Thu, 30 Nov 2023 10:10:34.973051000 UTC +00:00,
                updated_at: Thu, 30 Nov 2023 10:10:34.973051000 UTC +00:00,
                author_id: 4> 

        2. Retrieve multiple objects:
            2.1 find_each: 
                3.0.0 :018 > Book.find_each do |book|
                3.0.0 :019 >   puts book.name
                3.0.0 :020 > end
                op:
                Book Load (0.6ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT $1  [["LIMIT", 1000]]
                Rich Dad Poor Dad
                Song of ice and fire
                The Great Gatsby
                Lolita
                Story of my life
                Invisible Man
                Book A
                Book B
                Book C
                Book D
                => nil 

            To use conditions:
                3.0.0 :021 > Book.where(genre:nil).find_each do |book|
                3.0.0 :022 >   puts book.name
                3.0.0 :023 > end

            2.2: find_in_batches: The find_in_batches method is similar to find_each, since both retrieve batches of records.


        3. Conditions: The where method allows you to specify conditions to limit the records returned.

            3.1: String cond: 3.0.0 :027 > Book.where("name = 'Book A'")
                op:
                  Book Load (1.1ms)  SELECT "books".* FROM "books" WHERE (name = 'Book A') /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                 => 
                [#<Book:0x00007fb62b655f20
                  id: 10,
                  name: "Book A",
                  genre: nil,
                  created_at: Thu, 30 Nov 2023 11:50:58.576160000 UTC +00:00,
                  updated_at: Thu, 30 Nov 2023 11:50:58.576160000 UTC +00:00,
                  author_id: 2>]

            3.2: Array cond: 3.0.0 :033 > Book.where("name = '#{@book.name}'")
                    op:
                    Book Load (0.6ms)  SELECT "books".* FROM "books" WHERE (name = 'Book C') /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                    => 
                    [#<Book:0x00007fb62b8a7940
                    id: 12,
                    name: "Book C",
                    genre: nil,
                    created_at: Thu, 30 Nov 2023 11:51:37.828423000 UTC +00:00,
                    updated_at: Thu, 30 Nov 2023 11:51:37.828423000 UTC +00:00,
                    author_id: 2>] 

            3.3 Like in array cond: use sanitize_sql_like to escape wildcard characters in the relevant portion of the argument:

                    3.0.0 :036 > Book.where("name LIKE ?",Book.sanitize_sql_like(@book.name) + "%")
                    op:
                    Book Load (1.0ms)  SELECT "books".* FROM "books" WHERE (name LIKE 'Book C%') /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                    => 
                    [#<Book:0x00007fb62b68c6d8
                    id: 12,
                    name: "Book C",
                    genre: nil,
                    created_at: Thu, 30 Nov 2023 11:51:37.828423000 UTC +00:00,
                    updated_at: Thu, 30 Nov 2023 11:51:37.828423000 UTC +00:00,
                    author_id: 2>] 

            3.4 Hash cond: 3.0.0 :038 > Book.where(genre:nil)

                    To use range: 3.0.0 :045 > Book.where(id:(1..5))

                    Not cond: 3.0.0 :046 > Book.where.not(id:(1..5))

            3.5 Or cond: Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1, 3, 5]))

            3.6 And cond: Customer.where(last_name: 'Smith').where(orders_count: [1, 3, 5])

                          Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))

        4. Ordering: 3.0.0 :047 > Book.order(author_id: :desc).order(id: :desc)
                      OR
                    Book.order(title: :asc, created_at: :desc)
                    # OR
                    Book.order(:title, created_at: :desc)
                    # OR
                    Book.order("title ASC, created_at DESC")
                    # OR
                    Book.order("title ASC", "created_at DESC")

        5. Selecting Specific columns: 3.0.0 :049 > Book.select(:id,:name,:genre)
                    op:
                    => 
                    [#<Book:0x00007fb62b573990 id: 3, name: "Rich Dad Poor Dad", genre: "Finance">,
                    #<Book:0x00007fb62b573850 id: 5, name: "Song of ice and fire", genre: "History">,
                    #<Book:0x00007fb62b573710 id: 6, name: "The Great Gatsby", genre: nil>,
                    #<Book:0x00007fb62b5735d0 id: 7, name: "Lolita", genre: nil>,
                    #<Book:0x00007fb62b573490 id: 8, name: "Story of my life", genre: nil>,
                    #<Book:0x00007fb62b573350 id: 9, name: "Invisible Man", genre: nil>,
                    #<Book:0x00007fb62b573210 id: 10, name: "Book A", genre: nil>,
                    #<Book:0x00007fb62b5730d0 id: 11, name: "Book B", genre: nil>,
                    #<Book:0x00007fb62b572f90 id: 12, name: "Book C", genre: nil>,
                    #<Book:0x00007fb62b572e50 id: 13, name: "Book D", genre: nil>]

        6. Limit and Offset: Customer.limit(5).offset(30)

        7. Group by having: 3.0.0 :069 > Book.select(:genre).group(:genre)
                    op:
                      Book Load (0.7ms)  SELECT "books"."genre" FROM "books" GROUP BY "books"."genre" /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                     => 
                    [#<Book:0x00007fb62b56c820 id: nil, genre: nil>,
                     #<Book:0x00007fb62b56c5a0 id: nil, genre: "Finance">,
                     #<Book:0x00007fb62b56c460 id: nil, genre: "History">] 

                     Having:
                    3.0.0 :070 > Book.select(:genre).group(:genre).having("count(*) > 0")
                    op:
                    Book Load (0.6ms)  SELECT "books"."genre" FROM "books" GROUP BY "books"."genre" HAVING (count(*) > 0) /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                    => 
                    [#<Book:0x00007fb62b5a7308 id: nil, genre: nil>,
                    #<Book:0x00007fb62b5a71c8 id: nil, genre: "Finance">,
                    #<Book:0x00007fb62b5a7088 id: nil, genre: "History">] 

        8. Overriding Conditions: 
            8.1: unscope: remove that condition from query

            Eg: 3.0.0 :074 > Book.where("id>5").order("id desc").unscope(:order)

            8.2 only: considers the cond specified in only

            Eg: 3.0.0 :079 > Book.where("id>5").order("id desc").only(:order)

            8.3 reslect: reselects column by overriding prev select.

            Eg: 3.0.0 :080 > Book.select(:id).reselect(:name)

            8.4 reorder: reorders query result to specified order.

            Eg: 3.0.0 :082 > Book.select(:id).order(:id).reorder("id desc")

            8.5 reverse_order: reverses the order.

            8.6 rewhere: resets where cond

            Eg: 3.0.0 :084 > Book.where(author_id: 3).rewhere(author_id:2)

            8.7 regroup: resets grouping condition.
        
        9. Null relation: Return no output(empty relation) and fires no query.

        10. read only: makes the object(var) readonly and not modifiable.

            Eg: 3.0.0 :087 > book = Book.readonly.first

            This will give error on saving book after modifying it.

        11. Locking: Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.

            11.1: Optimistic locking: Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. 
             It does this by checking whether another process has made changes to a record since it was opened.

             Example:In order to use optimistic locking, the table needs to have a column called lock_version of type integer. Each time the record is updated, 
             Active Record increments the lock_version column. If an update request is made with a lower value in the lock_version field than is currently in the lock_version column in the database,
             the update request will fail with an ActiveRecord::StaleObjectError.
                
                b1 = Book.first
                b2 = Book.first

                b1.name = "Rich Dad Poor Dad"
                => "Rich Dad Poor Dad" 
                3.0.0 :007 > b1.save

                b2.name = "rich"
                => "rich" 
                3.0.0 :011 > b2.save
                Attempted to update a stale object: Book. (ActiveRecord::StaleObjectError)

            11.2 Pessimistice locking: Pessimistic locking uses a locking mechanism provided by the underlying database.
                Example:
                Book.transaction do
                    book = Book.lock.first
                    book.title = 'Algorithms, second edition'
                    book.save!
                end
        
        12. Joins: Active Record provides two finder methods for specifying JOIN clauses on the resulting SQL: joins and left_outer_joins.

            1. Joins: 
                1.1: Using string: 3.0.0 :017 > Book.joins("inner join authors on books.author_id = authors.id where books.genre is null")

                1.2 Using hash: 3.0.0 :020 > Book.joins(:author)

                1.3 joining multiple assoc: 3.0.0 :010 > Order.joins(:customer,:product)

                1.4 joining nested assoc: 3.0.0 :014 > Customer.joins(orders: :product) (Keep notice of singular name or plural name like here customer has many orders so orders instead of order)

                1.5 where condition: 3.0.0 :006 > Book.joins(:author).select(:name).where(genre:nil)
                    Book Load (0.6ms)  SELECT "books"."name" FROM "books" INNER JOIN "authors" ON "authors"."id" = "books"."author_id" WHERE "books"."genre" IS NULL /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
                    => 
                    [#<Book:0x00007f9c38fbe380 id: nil, name: "Book C">,
                    #<Book:0x00007f9c38fbe240 id: nil, name: "Book B">,
                    #<Book:0x00007f9c38fbe100 id: nil, name: "Book A">,
                    #<Book:0x00007f9c38fbdfc0 id: nil, name: "Book D">,
                    #<Book:0x00007f9c38fbde80 id: nil, name: "Invisible Man">,
                    #<Book:0x00007f9c38fbdd40 id: nil, name: "Story of my life">,
                    #<Book:0x00007f9c38fbdc00 id: nil, name: "Lolita">,
                    #<Book:0x00007f9c38fbdac0 id: nil, name: "The Great Gatsby">]

            2. left_outer_joins: If you want to select a set of records whether or not they have associated records you can use the left_outer_joins method.

                Eg: 3.0.0 :012 > Author.left_outer_joins(:books).where('authors.id > 3')
                Author Load (0.8ms)  SELECT "authors".* FROM "authors" LEFT OUTER JOIN "books" ON "books"."author_id" = "authors"."id" WHERE (authors.id > 3) /* loading for pp */ LIMIT $1  [["LIMIT", 11]]

            3. where.associated & where.missing: The associated and missing query methods let you select a set of records based on the presence or absence of an association.

                Eg: 3.0.0 :013 > Author.where.missing(:books)
                Author Load (0.5ms)  SELECT "authors".* FROM "authors" LEFT OUTER JOIN "books" ON "books"."author_id" = "authors"."id" WHERE "books"."id" IS NULL /* loading for pp */ LIMIT $1  [["LIMIT", 11]]

                Eg: 3.0.0 :014 > Author.where.associated(:books)
                Author Load (0.6ms)  SELECT "authors".* FROM "authors" INNER JOIN "books" ON "books"."author_id" = "authors"."id" WHERE "books"."id" IS NOT NULL /* loading for pp */ LIMIT $1 

        13. Eager Loading: Eager loading is the mechanism for loading the associated records of the objects returned by Model.find using as few queries as possible.

                N+1 query problem
                books = Book.limit(10)

                books.each do |book|
                puts book.author.last_name
                end

                The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = 11 queries in total.

                - Solution for n+1 problem: Active Record lets you specify in advance all the associations that are going to be loaded.

                    The methods are:

                    includes
                    preload
                    eager_load

                1. includes: With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.


        
        14. Dynamic Finders: If you have a field called first_name on your Customer model for example, you get the instance method find_by_first_name for free from Active Record. 
         If you also have a locked field on the Customer model, you also get find_by_locked method. Active record provide these dynamic finder methods.

            Eg:
            3.0.0 :022 > Book.find_by_name!("Rich Dad Poor Dad")
            Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."name" = $1 LIMIT $2  [["name", "Rich Dad Poor Dad"], ["LIMIT", 1]]

        15. Enums: An enum lets you define an Array of values for an attribute and refer to them by name. The actual value stored in the database is an integer that has been mapped to one of the values.
         
            Eg:
            class Book < ApplicationRecord
                belongs_to :author
                enum :name, [:rishab,:lovansh]
            end

            3.0.0 :011 > Book.lovansh.first
            Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."name" = $1 ORDER BY "books"."id" ASC LIMIT $2  [["name", "1"], ["LIMIT", 1]]
            => 
            #<Book:0x00007effefe2e258
            id: 14,
            name: nil,
            genre: nil,
            created_at: Fri, 01 Dec 2023 11:27:44.573701000 UTC +00:00,
            updated_at: Fri, 01 Dec 2023 11:27:44.573701000 UTC +00:00,
            author_id: 5,
            lock_version: 0>

            here name is showing null because it is mapped with integer value of index of enum

        16. Method chaining: means we can chain various active record methods like where joins etc to query result.

            Example:
            3.0.0 :023 > Author.select('authors.name,books.name').joins(:books).where('authors.id = 3')
            Author Load (0.9ms)  SELECT authors.name,books.name FROM "authors" INNER JOIN "books" ON "books"."author_id" = "authors"."id" WHERE (authors.id = 3) /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
            => 
            [#<Author:0x00007effe8696420 id: nil, name: "Rich Dad Poor Dad">,
            #<Author:0x00007effe86962e0 id: nil, name: "Lolita">,
            #<Author:0x00007effe86961a0 id: nil, name: "Story of my life">,
            #<Author:0x00007effe8696060 id: nil, name: "Invisible Man">,
            #<Author:0x00007effe8695f20 id: nil, name: "Book D">] 

        17. find or build a new object: 
            17.1 find_or_create_by: 3.0.0 :017 > Customer.find_or_create_by!(name:"Sanya")
  
                Customer Load (0.4ms)  SELECT "customers".* FROM "customers" WHERE "customers"."name" = $1 LIMIT $2  [["name", "Sanya"], ["LIMIT", 1]]
                TRANSACTION (0.2ms)  BEGIN
                Customer Create (29.2ms)  INSERT INTO "customers" ("name", "mobile", "adhar_number", "created_at", "updated_at", "start", "end") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"  [["name", "Sanya"], ["mobile", nil], ["adhar_number", nil], ["created_at", "2023-12-01 11:47:48.220084"], ["updated_at", "2023-12-01 11:47:48.220084"], ["start", nil], ["end", nil]]
                TRANSACTION (16.4ms)  COMMIT

            17.2 find_or_create_by!: return error if validation not passed while object creation.

            17.3 find_or_initialize_by: The find_or_initialize_by method will work just like find_or_create_by but it will call new instead of create. This means that a new model instance will be created in memory but won't be saved to the database.

        18. finding by sql: 3.0.0 :027 > Book.find_by_sql("select * from books where books.genre is not null")
            op:
            Book Load (1.0ms)  select * from books where books.genre is not null
            => 
            [#<Book:0x00007effe8434880
            id: 5,
            name: nil,
            genre: "History",
            created_at: Thu, 30 Nov 2023 06:58:26.740268000 UTC +00:00,
            updated_at: Thu, 30 Nov 2023 06:58:26.740268000 UTC +00:00,
            author_id: 2,
            lock_version: 0>,
            #<Book:0x00007effe8434740
            id: 3,
            name: nil,
            genre: "Finance",
            created_at: Thu, 30 Nov 2023 05:15:31.096338000 UTC +00:00,
            updated_at: Fri, 01 Dec 2023 09:29:09.231075000 UTC +00:00,
            author_id: 3,
            lock_version: 1>] 

            18.2 select_all: returns an array of hash of each record.
            
                Book.connection.select_all("select * from books where books.genre is not null").to_a
                op:
                (0.4ms)  select * from books where books.genre is not null
                => 
                [{"id"=>5,
                "name"=>"Song of ice and fire",
                "genre"=>"History",
                "created_at"=>2023-11-30 06:58:26.740268 UTC,
                "updated_at"=>2023-11-30 06:58:26.740268 UTC,
                "author_id"=>2,
                "lock_version"=>nil},
                {"id"=>3,
                "name"=>"Rich Dad Poor Dad",
                "genre"=>"Finance",
                "created_at"=>2023-11-30 05:15:31.096338 UTC,
                "updated_at"=>2023-12-01 09:29:09.231075 UTC,
                "author_id"=>3,
                "lock_version"=>1}] 

            18.3 pluck: similar to select. returns an array of result.

                Eg: 3.0.0 :020 > Book.pluck(:name)
                Book Pluck (0.5ms)  SELECT "books"."name" FROM "books"
                => ["Invisible Man", "Song of ice and fire", "Rich Dad Poor Dad", "Lolita"] 

            18.4 pick: similar to pluck just return only one output.

            18.5 ids: returns array of ids.

        19. existence of a record: 

            Eg1: 3.0.0 :024 > Book.exists?(name:"Lolita")
            Book Exists? (0.6ms)  SELECT 1 AS one FROM "books" WHERE "books"."name" = $1 LIMIT $2  [["name", "Lolita"],

            Multiple args (will return true even if one argument is found)
            Eg2: 3.0.0 :025 > Book.exists?(name:["Lolita","Avneet"])
            Book Exists? (1.0ms)  SELECT 1 AS one FROM "books" WHERE "books"."name" IN ($1, $2) LIMIT $3  [["name", "Lolita"], ["name", "Avneet"], ["LIMIT", 1]]
            => true 

        20. Explain: Active Record performs a pretty printing that emulates that of the corresponding database shell. 
         So, the same query running with the PostgreSQL adapter would yield instead

            3.0.0 :032 > Book.where(id:17).explain
            Book Load (0.4ms)  SELECT "books".* FROM "books" WHERE "books"."id" = $1  [["id", 17]]
            => 
            EXPLAIN SELECT "books".* FROM "books" WHERE "books"."id" = $1 [["id", 17]]
                                            QUERY PLAN
            --------------------------------------------------------------------------
            Index Scan using books_pkey on books  (cost=0.15..8.17 rows=1 width=100)
            Index Cond: (id = '17'::bigint)
            (2 rows)

        21. Scope: Scoping allows you to specify commonly-used queries which can be referenced as method calls on the association objects or models.

            Eg: We have to find books having no genre many times so we create a scope in book model.

            class Book < ApplicationRecord
                belongs_to :author
                scope :no_genre, -> { where(genre:nil) }
            end

            Console:
            3.0.0 :004 > Book.no_genre
            Book Load (0.3ms)  SELECT "books".* FROM "books" WHERE "books"."genre" IS NULL /* loading for pp */ LIMIT $1  [["LIMIT", 11]]

            - Scope with arguments:

            Eg:
            scope :price_more_than, ->(amount){where("price > ?", amount)}

            Console:
            3.0.0 :003 > Product.price_more_than(50000)
            Product Load (0.8ms)  SELECT "products".* FROM "products" WHERE (price > 50000) /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
            => 
            [#<Product:0x00007fdf99f743d0
            id: 9,
            name: "iphone-14",
            price: 60000,
            created_at: Wed, 29 Nov 2023 10:29:23.232318000 UTC +00:00,
            updated_at: Wed, 29 Nov 2023 10:29:23.232318000 UTC +00:00>] 


            - Default scope: this scope applies by default to all queries of the model.

            Eg:
            default_scope {where("price > ?", 40000)}

            Console:
            3.0.0 :006 > Product.all
            Product Load (0.4ms)  SELECT "products".* FROM "products" WHERE (price > 40000) /* loading for pp */ LIMIT $1  [["LIMIT", 11]]

            - We can use two or more scopes like in chaining.

            - unscope a scope: it can be used to nullify the effect caused by the default scope or any scopes.

            Eg:
            3.0.0 :008 > Product.unscoped.all
            Product Load (0.4ms)  SELECT "products".* FROM "products" /* loading for pp */ LIMIT $1  [["LIMIT", 11]]
            => 

    36. How to search in model using forms(taking input from user):
    search view:

    <%= form_tag(users_path, method: :get) do %>
        <%= label_tag :id, "Search by ID:" %>
        <%= text_field_tag :id %>
        <%= submit_tag "Search" %>
    <% end %>


        - in form_tag users_path is the action that is where the inputs given will be taken for processing.
        - method specifies the type of action we want to perform from this form.
        - ensure to keep the name attribute same here it is :id.

    in users_path file that is our index action:
    
    def index
        @users = User.all

        if params[:id].present?
        @search_results = User.find_by(id: params[:id])
        redirect_to user_url(@search_results.id)
        else
        @search_results = nil
        end

    end

        - params contains the all the input given by the user we will access the parameter id
        and then redirect the page to show action using user_url in controller.
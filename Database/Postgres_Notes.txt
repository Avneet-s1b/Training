                            POSTGRESQL
    
    HOW TO ENTER PSQL MODE
        - 'sudo -i -u postgres'
            This will change user to postgres through it we can enter psql mode 
        - 'psql'
            This will start the psql mode 
        - 'help'
            To seek help 
        - '\q' 
            To exit psql mode 
        - '\l'
            To list all the databases.

            Example:
            Name    |  Owner   | Encoding | Collate | Ctype | ICU Locale | Locale Provider |   Access privileges   
            -----------+----------+----------+---------+-------+------------+-----------------+-----------------------
            postgres  | postgres | UTF8     | en_IN   | en_IN |            | libc            | 
            template0 | postgres | UTF8     | en_IN   | en_IN |            | libc            | =c/postgres          +
                    |          |          |         |       |            |                 | postgres=CTc/postgres
            template1 | postgres | UTF8     | en_IN   | en_IN |            | libc            | =c/postgres          +
                    |          |          |         |       |            |                 | postgres=CTc/postgres
            test      | postgres | UTF8     | en_IN   | en_IN |            | libc            | 
            (4 rows)

            

    HOW TO CREATE A DB IN PSQL 
        - 'CREATE DATABASE db_name;'

        Example: CREATE DATABASE market;
        Result: CREATE DATABASE
                Name    |  Owner   | Encoding | Collate | Ctype | ICU Locale | Locale Provider |   Access privileges   
                -----------+----------+----------+---------+-------+------------+-----------------+-----------------------
                market    | postgres | UTF8     | en_IN   | en_IN |            | libc            | 
                postgres  | postgres | UTF8     | en_IN   | en_IN |            | libc            | 
                template0 | postgres | UTF8     | en_IN   | en_IN |            | libc            | =c/postgres          +
                        |          |          |         |       |            |                 | postgres=CTc/postgres
                template1 | postgres | UTF8     | en_IN   | en_IN |            | libc            | =c/postgres          +
                        |          |          |         |       |            |                 | postgres=CTc/postgres
                test      | postgres | UTF8     | en_IN   | en_IN |            | libc            | 
                (5 rows)


    HOW TO CONNECT TO DB 
        - '\c db_name'
        Example: \c market 
        Result: You are now connected to database "market" as user "postgres".


    HOW TO DELETE A DB 
        - 'DROP DATABASE db_name'

        Example: DROP DATABASE school_db
        Result: DROP DATABASE (Deletes db school_db)

        - 'DROP DATABASE IF EXISTS db_name'
        this prevents error if database doesnot exist
    
    HOW TO CREATE A TABLE
        - 'CREATE TABLE table_name (
            id INT NOT NULL PRIMARY KEY,
            ...
        )

        Example: 
                market=# CREATE TABLE customer (
                market(# id BIGSERIAL NOT NULL PRIMARY KEY,
                market(# first_name VARCHAR(50) NOT NULL,
                market(# last_name VARCHAR(50) NOT NULL,
                market(# mobile VARCHAR(50) NOT NULL,
                market(# email VARCHAR(50));
        
        Result: CREATE TABLE

        - HOW TO SET A COMPOSITE PRIMARY KEY 

        Example: CREATE TABLE contact(
                attend_mgmt(# emp_id INT NOT NULL,
                attend_mgmt(# mobile_no INT NOT NULL,
                attend_mgmt(# PRIMARY KEY(emp_id,mobile_no));
        Result:                 Table "public.contact"
                Column   |  Type   | Collation | Nullable | Default 
                -----------+---------+-----------+----------+---------
                emp_id    | integer |           | not null | 
                mobile_no | integer |           | not null | 
                Indexes:
                    "contact_pkey" PRIMARY KEY, btree (emp_id, mobile_no)



    HOW TO DISPLAY A TABLE 
        - '\d' (to view all the tables in db)
        Example:
                            List of relations
                Schema |      Name       |   Type   |  Owner   
                --------+-----------------+----------+----------
                public | customer        | table    | postgres
                public | customer_id_seq | sequence | postgres
                (2 rows)

                We can do 'dt' to show tables only

        - '\d table_name' (to view specific table)

        Example:
                                                    Table "public.customer"
                Column   |         Type          | Collation | Nullable |               Default                
                ------------+-----------------------+-----------+----------+--------------------------------------
                id         | bigint                |           | not null | nextval('customer_id_seq'::regclass)
                first_name | character varying(50) |           | not null | 
                last_name  | character varying(50) |           | not null | 
                mobile     | character varying(50) |           | not null | 
                email      | character varying(50) |           |          | 
                Indexes:
                    "customer_pkey" PRIMARY KEY, btree (id)


    HOW TO DELETE A TABLE 
        - 'DROP TABLE table_name'

    HOW TO INSERT VALUES INTO TABLE
        - market=# INSERT INTO customer (first_name , last_name , mobile , email)
          market-# VALUES ('Avneet' , 'Singh' , '8178646325' , 'avneet@gmail.com' );
        
        Result: INSERT 0 1


    CREATE A SCHEMA 
        - A schema is a named collection of tables. It organizes database objects into 
        logical groups to make them more manageable.

        - CREATE SCHEMA myschema;
        Result: CREATE SCHEMA

    CREATE A TABLE IN A SCHEMA 
     
        - CREATE TABLE myschema.schematable(
            market(# id INT
            market(# , fist_name VARCHAR(50));
        Result : CREATE TABLE


    DROP A SCHEMA 

        -  DROP SCHEMA myschema CASCADE;
        Result: NOTICE:  drop cascades to table myschema.schematable
                DROP SCHEMA

        - DROP SCHEMA myschema (if the schema is empty)



    VIEW A TABLE (SELECT QUERY)

        - SELECT * FROM customer;
        Result:   
                id | first_name | last_name |   mobile   |       email        
                ----+------------+-----------+------------+--------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                2 | Kunal      |           | 8178646325 | avneet@gmail.com
                3 | Vipul      | Kumar     | 8178645625 | vipsi@gmail.com
                4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                5 | Ishita     | Saxena    | 4538644585 | isaxerna@gmail.com
                (5 rows)


    UPDATE A TABLE ENTRY

        - UPDATE customer SET age = null WHERE gender='Female';
        Result: UPDATE 1

        Change in table: 
                id | first_name | last_name | gender | age 
                ----+------------+-----------+--------+-----
                1 | Avneet     | Singh     | Male   |  22
                2 | Kunal      | Singh     | Male   |  20
                3 | Deepak     | Chaudhary | Male   |  30
                4 | Vipul      | Kumar     | Male   |  15
                5 | Naman      | Chaudhary | Male   |  22
                6 | Vishakha   | Pandey    | Female |    
                (6 rows)


    ORDER BY QUERY
        - used to sort in asc or desc order.

        - SELECT id,first_name FROM customer ORDER BY id DESC;
        Result: 
                id | first_name 
                ----+------------
                5 | Ishita
                4 | Deepak
                3 | Vipul
                2 | Kunal
                1 | Avneet
                (5 rows)


    DISTINCT QUERY 
        - used to show distinct items

        - SELECT DISTINCT(mobile) FROM customer;
        Result:       
                mobile   
                ------------
                8178645625
                8178646325
                9978644585
                4538644585
                (4 rows)


    WHERE, AND, OR, QUERY
        - where is used to specify a condition

        - SELECT id,first_name FROM customer WHERE email = 'avneet@gmail.com' OR first_name = 'Deepak';
        Result:
                id | first_name 
                ----+------------
                1 | Avneet
                2 | Kunal
                4 | Deepak
                (3 rows)


    COMPARISON OPERATORS (<,<=,>,>=,=,<>(not equal),!=)
        
        - SELECT * FROM customer WHERE id <= 3;
        Result:
                id | first_name | last_name |   mobile   |      email       
                ----+------------+-----------+------------+------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                2 | Kunal      |           | 8178646325 | avneet@gmail.com
                3 | Vipul      | Kumar     | 8178645625 | vipsi@gmail.com
                (3 rows)


    LIMIT OFFSET FETCH 

        - these are used to limit the number of results shown to a user.

            Limit: SELECT * FROM customer LIMIT 2;

            Result: 
                    id | first_name | last_name |   mobile   |      email       
                    ----+------------+-----------+------------+------------------
                    1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                    2 | Kunal      |           | 8178646325 | avneet@gmail.com
                    (2 rows)

            Offset: SELECT * FROM customer LIMIT 2 OFFSET 2;
            Result:id | first_name | last_name |   mobile   |      email      
                    ----+------------+-----------+------------+-----------------
                    3 | Vipul      | Kumar     | 8178645625 | vipsi@gmail.com
                    4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                    (2 rows)

            Fetch: SELECT * FROM customer FETCH FIRST 2 ROW ONLY OFFSET 3;
            result: id | first_name | last_name |   mobile   |       email        
                    ----+------------+-----------+------------+--------------------
                    4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                    5 | Ishita     | Saxena    | 4538644585 | isaxerna@gmail.com
                    (2 rows)


    IN QUERY 
        - To search in a specific group specified by user 

        - SELECT * FROM customer WHERE first_name IN ('Avneet','kunal','Deepak');
        
        Result: id | first_name | last_name |   mobile   |      email       
                ----+------------+-----------+------------+------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                (2 rows)

    BETWEEN QUERY 
         
        - SELECT * FROM customer WHERE id BETWEEN 2 AND 4;
        
        Result: id | first_name | last_name |   mobile   |      email       
                ----+------------+-----------+------------+------------------
                2 | Kunal      |           | 8178646325 | avneet@gmail.com
                3 | Vipul      | Kumar     | 8178645625 | vipsi@gmail.com
                4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                (3 rows)


    LIKE & ILIKE 

        - Like:  SELECT * FROM customer WHERE first_name LIKE '%eet';
        Result: id | first_name | last_name |   mobile   |      email       
                ----+------------+-----------+------------+------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                (1 row)

        - Ilike: (Case insensitive) SELECT * FROM customer WHERE first_name ILIKE '%eEt';
        Result: id | first_name | last_name |   mobile   |      email       
                ----+------------+-----------+------------+------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                (1 row) 


    GROUP BY 
        - groups on specific property

        - SELECT last_name,COUNT(*) FROM customer GROUP BY last_name;
        
        Result:last_name  | count 
                -----------+-------
                          |     1
                Singh     |     2
                Chaudhary |     1
                Kumar     |     3
                Rautela   |     1
                Saxena    |     1
                (6 rows)

        orignal table :
                id | first_name | last_name |   mobile   |       email        
                ----+------------+-----------+------------+--------------------
                1 | Avneet     | Singh     | 8178646325 | avneet@gmail.com
                2 | Kunal      |           | 8178646325 | avneet@gmail.com
                3 | Vipul      | Kumar     | 8178645625 | vipsi@gmail.com
                4 | Deepak     | Chaudhary | 9978644585 | dpkk@gmail.com
                5 | Ishita     | Saxena    | 4538644585 | isaxerna@gmail.com
                6 | Kunal      | Rautela   | 9846327810 | rautela@gmail.com
                7 | Vishakha   | Kumar     | 9346386210 | vish@gmail.com
                8 | Chaitanya  | Kumar     | 2345678710 | chitts@gmail.com
                9 | Naman      | Singh     | 2345558710 | ns@gmail.com
                (9 rows)


        Example: using SUM 

        - SELECT last_name , SUM(id) FROM customer GROUP BY last_name ORDER BY SUM(id);
        
        Result: last_name | sum 
                -----------+-----
                          |   2
                Chaudhary |   4
                Saxena    |   5
                Rautela   |   6
                Singh     |  10
                Kumar     |  18
                (6 rows)


    GROUP BY HAVING 
        - always use after group by not before or very later in query.

        - SELECT last_name,COUNT(*) FROM customer GROUP BY last_name HAVING COUNT(*)>=2;
        Result: last_name | count 
                -----------+-------
                Singh     |     2
                Kumar     |     3
                (2 rows)


    MIN, MAX, AVG, SUM 

        Table:
                id |   name   | company | price  
                ----+----------+---------+--------
                1 | Iphone13 | Apple   |  80000
                3 | S23      | Samsung |  80000
                4 | Pixel    | Google  |  80000
                5 | Galaxy   | Samsung |  80000
                6 | Iphone15 | Apple   | 100000
                7 | Iphone6  | Apple   |  15000
                2 | Note8    | Redmi   |  20000
                8 | Fold     | Samsung | 130000
                9 | Note10   | Redmi   |  40000
                (9 rows)

        Max: SELECT company,MAX(price) FROM product GROUP BY company;
        Result: company |  max   
                ---------+--------
                Google  |  80000
                Samsung | 130000
                Redmi   |  40000
                Apple   | 100000
                (4 rows)

        Avg: SELECT company,ROUND(AVG(price),2) FROM product GROUP BY company;
        Result: company |  round   
                ---------+----------
                Google  | 80000.00
                Samsung | 96666.67
                Redmi   | 30000.00
                Apple   | 65000.00
                (4 rows)


    HOW TO MANIPULATE DATA (ARITHMETIC OPERATIONS)
        - We can make new columns while returning using select statement and also manipulate data
        from already existing columns too in these new columns.

        - SELECT name , company , price AS original_price , ROUND(price - price*0.1) AS ten_percent_discount_price FROM product;
        Result:   name   | company | original_price | ten_percent_discount_price 
                ----------+---------+----------------+----------------------------
                Iphone13 | Apple   |          80000 |                      72000
                S23      | Samsung |          80000 |                      72000
                Pixel    | Google  |          80000 |                      72000
                Galaxy   | Samsung |          80000 |                      72000
                Iphone15 | Apple   |         100000 |                      90000
                Iphone6  | Apple   |          15000 |                      13500
                Note8    | Redmi   |          20000 |                      18000
                Fold     | Samsung |         130000 |                     117000
                Note10   | Redmi   |          40000 |                      36000
                (9 rows)

    ALIAS
        - changing name of columns using AS keyword.

    COALESCE
        - it is a fn which returns the first non null value.

        - SELECT first_name,COALESCE( age , 0) FROM customer;
        Result: first_name | coalesce 
                ------------+----------
                Avneet     |       22
                Kunal      |       20
                Deepak     |       30
                Vipul      |       15
                Naman      |       22
                Vishakha   |        0
                (6 rows)

    
    NULLIF
        - it takes to input parameters and gives output 

            NULLIF(EXPR1,EXPR2) 

            if expr1=expr2 then it return null else it returns expr1.

            Example:
            NULLIF(0,0) = null 
            NULLIF(10,0) = 10


    NOW 
        - used to print date and time 

        - SELECT NOW();
        Result:          now                
            ----------------------------------
            2023-10-26 18:06:37.565344+05:30
            (1 row)

        - SELECT NOW()::DATE;
        Result:     now     
                ------------
                2023-10-26
                (1 row)

        - SELECT NOW()::TIME;
        Result:   now       
            -----------------
            18:07:59.335877
            (1 row)


        - MANIPULATION IN NOW():
            SELECT (NOW() + INTERVAL '10 YEARS')::DATE;
            Result:    date    
                    ------------
                    2033-10-27
                    (1 row)

            Similarly, can be done for DAYS(date), MONTHS.

        
        -EXTRACTING FIELDS FROM NOW()
            SELECT EXTRACT(YEAR FROM NOW());
            Result:  extract 
                    ---------
                        2023
                    (1 row)

            Here we can also exxtract DOW (day of week)


            Another Example:

            SELECT EXTRACT(DAY FROM (NOW() - INTERVAL '1 DAYS'));
            Result:  extract 
                    ---------
                        26
                    (1 row)

            
        -AGE() CALCULATION FROM NOW 
            SELECT AGE(NOW(), '2001-07-19');
            Result:                age                   
                    ----------------------------------------
                    22 years 3 mons 8 days 10:58:31.189239
                    (1 row)


            SELECT EXTRACT ( YEAR FROM ( AGE(NOW(),'2001-07-19')));
            Result:  extract 
                    ---------
                        22
                    (1 row)



    ALTER TABLE
        - DROP CONSTRAINT:
            ALTER TABLE practice DROP CONSTRAINT practice_pkey;
            Result: ALTER TABLE (now table will no longer have primary key constraint to id)

                    Table before:
                        id | first_name | date_of_birth 
                        ----+------------+---------------
                        1 | Raman      | 2004-09-15
                        (1 row)

                    Table after can have two entries with same id:
                        id | first_name | date_of_birth 
                        ----+------------+---------------
                        1 | Raman      | 2004-09-15
                        1 | Raman      | 2004-09-15
                        (2 rows)

        - ADD PRIMARY KEY CONSTRAINT:
            ALTER TABLE practice ADD PRIMARY KEY (id);
            Result: ALTER TABLE

            In table now id will be a primary key: 
                                                    Table "public.practice"
                    Column     |         Type          | Collation | Nullable |               Default                
                ---------------+-----------------------+-----------+----------+--------------------------------------
                id            | bigint                |           | not null | nextval('practice_id_seq'::regclass)
                first_name    | character varying(50) |           | not null | 
                date_of_birth | character varying(50) |           | not null | 
                Indexes:
                    "practice_pkey" PRIMARY KEY, btree (id)


        - ADD CONSTRAINT:
            ALTER TABLE practice ADD CONSTRAINT unique_first_name UNIQUE (first_name);
            Result : ALTER TABLE

                                                   Table "public.practice"
                    Column     |         Type          | Collation | Nullable |               Default                
                ---------------+-----------------------+-----------+----------+--------------------------------------
                id            | bigint                |           | not null | nextval('practice_id_seq'::regclass)
                first_name    | character varying(50) |           | not null | 
                date_of_birth | character varying(50) |           | not null | 
                Indexes:
                    "practice_pkey" PRIMARY KEY, btree (id)
                    "unique_first_name" UNIQUE CONSTRAINT, btree (first_name)


            Another way to add a unique constraint is:
            ALTER TABLE practice ADD UNIQUE (first_name);

                                                   Table "public.practice"
                    Column     |         Type          | Collation | Nullable |               Default                
                ---------------+-----------------------+-----------+----------+--------------------------------------
                id            | bigint                |           | not null | nextval('practice_id_seq'::regclass)
                first_name    | character varying(50) |           | not null | 
                date_of_birth | character varying(50) |           | not null | 
                Indexes:
                    "practice_pkey" PRIMARY KEY, btree (id)
                    "practice_first_name_key" UNIQUE CONSTRAINT, btree (first_name)

        
        - ADD A CHECK CONSTRAINT : it is used to specify values that can be entered in a col like male/female only in gender col.
             ALTER TABLE practice ADD CONSTRAINT dob_constraint CHECK (date_of_birth = '2001-07-19');
            Result: ALTER TABLE

                                                   Table "public.practice"
                Column     |         Type          | Collation | Nullable |               Default                
            ---------------+-----------------------+-----------+----------+--------------------------------------
            id            | bigint                |           | not null | nextval('practice_id_seq'::regclass)
            first_name    | character varying(50) |           | not null | 
            date_of_birth | character varying(50) |           | not null | 
            Indexes:
                "practice_pkey" PRIMARY KEY, btree (id)
                "unique_first_name" UNIQUE CONSTRAINT, btree (first_name)
            Check constraints:
                "dob_constraint" CHECK (date_of_birth::text = '2001-07-19'::text)

    
    DELETE AN ENTRY 
        -DELETE FROM practice WHERE id = 3;
        Result: DELETE 1

        table before:
            id | first_name | date_of_birth 
            ----+------------+---------------
            3 | Avneet     | 2001-07-19
            (1 row)

        table after:
            id | first_name | date_of_birth 
            ----+------------+---------------
            (0 rows)

    UPDATE AN ENTRY 
        -UPDATE practice SET first_name = 'Avi';
        Result: UPDATE 1
               
        TABLE AFTER:
                id | first_name | date_of_birth 
                ----+------------+---------------
                3 | Avi        | 2001-07-19
                (1 row)


    ON CONFLICT
        - DO NOTHING: 

            Command:INSERT INTO practice (id, first_name , date_of_birth)
                    VALUES (3, 'Avneet' , '2001-07-19')
                    ON CONFLICT(id) DO NOTHING;
            Result: INSERT 0 0

            on adding same id entry this command doesnt show error instead it does nothing 

        - UPSERT

            Command:INSERT INTO practice (id, first_name , date_of_birth)
                    VALUES (3, 'Avneet' , '2001-07-19')
                    ON CONFLICT(id) DO UPDATE SET first_name = EXCLUDED.first_name;
            Result: INSERT 0 1

            Table now: 
                        id | first_name | date_of_birth 
                        ----+------------+---------------
                        3 | Avneet     | 2001-07-19
                        (1 row)



    JOINS
        - A JOIN clause is used to combine rows from two or more tables,
        based on a related column between them.

        - parent table - table whose colimn is refrenced
          child table - table that refrences the column from other table 

        Example:

            Table 1: (parent)       
            CREATE TABLE car (
            test(# car_id BIGSERIAL NOT NULL PRIMARY KEY,
            test(# make VARCHAR(50) NOT NULL,
            test(# model VARCHAR(50) NOT NULL,
            test(# price INT NOT NULL);

            car_id |   make   | model  |  price  
            --------+----------+--------+---------
                1 | Maruti   | WagonR |  600000
                2 | Mahindra | Thar   | 1500000
                3 | Hyundai  | Creta  | 1500000
                4 | Maruti   | Swift  |  900000

            Table 2:(child)
            CREATE TABLE person (
            test(# id BIGSERIAL NOT NULL PRIMARY KEY,
            test(# first_name VARCHAR(50) NOT NULL,
            test(# last_name VARCHAR(50) NOT NULL,
            test(# mobile VARCHAR(50) NOT NULL,
            test(# date_of_birth VARCHAR(50) NOT NULL,
            test(# car_id INT REFERENCES car (car_id));
            
            id | first_name | last_name |   mobile   | date_of_birth | car_id 
            ----+------------+-----------+------------+---------------+--------
            1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |       
            2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |       
            3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |       
            4 | Karan      | Pant      | 5611112567 | 1996-06-10    |       
            5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |       
            (5 rows)

            Now we have to establish the join relation by passing in the value of car_id in person.

        
        -UPDATING JOINS:

            Command: UPDATE person SET car_id = 3 WHERE id = 1;

            this will set car_id = 3 in person table in row having id = 1;

        
        -INNER JOIN: selects records that have matching values in both tables.

            Command: SELECT * FROM person JOIN car ON person.car_id = car.car_id;
                    
            Result:id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   | model  |  price  
                    ----+------------+-----------+------------+---------------+--------+--------+----------+--------+---------
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta  | 1500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift  |  900000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR |  600000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar   | 1500000
                    (4 rows)

            Another way of inner join : SELECT * FROM person INNER JOIN car ON person.car_id = car.car_id;

        - LEFT JOIN: used to show all the values in first table along with common values in sec table.

            Command: SELECT * FROM person LEFT JOIN car ON person.car_id = car.car_id ORDER BY person.id;
            Result:id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   | model  |  price  
                    ----+------------+-----------+------------+---------------+--------+--------+----------+--------+---------
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta  | 1500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift  |  900000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |        |          |        |        
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR |  600000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar   | 1500000
                    (5 rows)

        
        - RIGHT JOIN: SELECT * FROM person RIGHT JOIN car ON person.car_id = car.car_id;
 
            Result:id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   |  model  |  price  
                    ----+------------+-----------+------------+---------------+--------+--------+----------+---------+---------
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta   | 1500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift   |  900000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR  |  600000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar    | 1500000
                        |            |           |            |               |        |      5 | Mahindra | Scorpio | 2500000
                    (5 rows)

        
        - FULL JOIN: SELECT * FROM person RIGHT JOIN car ON person.car_id = car.car_id
                     UNION
                     SELECT * FROM person LEFT JOIN car ON person.car_id = car.car_id;
            Result:    id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   |  model  |  price  
                        ----+------------+-----------+------------+---------------+--------+--------+----------+---------+---------
                        3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |        |          |         |        
                        4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR  |  600000
                        2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift   |  900000
                            |            |           |            |               |        |      5 | Mahindra | Scorpio | 2500000
                        5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar    | 1500000
                        1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta   | 1500000
                        (6 rows)

        - CROSS JOIN: SELECT * FROM person CROSS JOIN car;
            Result:id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   |  model  |  price  
                    ----+------------+-----------+------------+---------------+--------+--------+----------+---------+---------
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |      1 | Maruti   | WagonR  |  600000
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      1 | Maruti   | WagonR  |  600000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      1 | Maruti   | WagonR  |  600000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR  |  600000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      1 | Maruti   | WagonR  |  600000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |      2 | Mahindra | Thar    | 1500000
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      2 | Mahindra | Thar    | 1500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      2 | Mahindra | Thar    | 1500000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      2 | Mahindra | Thar    | 1500000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar    | 1500000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |      3 | Hyundai  | Creta   | 1500000
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta   | 1500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      3 | Hyundai  | Creta   | 1500000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      3 | Hyundai  | Creta   | 1500000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      3 | Hyundai  | Creta   | 1500000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |      4 | Maruti   | Swift   |  900000
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      4 | Maruti   | Swift   |  900000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift   |  900000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      4 | Maruti   | Swift   |  900000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      4 | Maruti   | Swift   |  900000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |        |      5 | Mahindra | Scorpio | 2500000
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      5 | Mahindra | Scorpio | 2500000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      5 | Mahindra | Scorpio | 2500000
                    4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      5 | Mahindra | Scorpio | 2500000
                    5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      5 | Mahindra | Scorpio | 2500000
                    (25 rows)

        - SELF JOIN: It is used to get the output from a particular table when the same table is joined to itself.

                    SELECT columns FROM table as t1 INNER JOIN table as t2 ON t1.id = t2.id;

        
        - JOIN OPERATION WITHOUT JOIN KEYWORD: SELECT person.first_name, car.model, car.price FROM  person,car WHERE person.car_id = car.car_id;
            Result: first_name | model  |  price  
                    ------------+--------+---------
                    Avneet     | Creta  | 1500000
                    Deepak     | Swift  |  900000
                    Karan      | WagonR |  600000
                    Kamal      | Thar   | 1500000
                    (4 rows)

    DELETE OPERATION ON FORIEGN KEY 
        A key cant be deleted from a parent table till it is present in child table that is being refrenced

        - We can do it in 3 ways:
            1. manually removing foriegn key from child table by updating it to null ordeleting the whole row
            and then using delete from to delete in parent table.

            2. ON DELETE CASECADE: set as a constraint while making the child table. it will automaticlly delete
            the row that is refrencing the fk when fk is deleted in the parent table.

            3. ON DELETE SET NULL: insteadof deleting whole row in child table it will set the fk value in child table
            to null. 

            Example: create table newcustomer (
                    test(# id BIGSERIAL NOT NULL PRIMARY KEY,
                    test(#  first_name VARCHAR(50) NOT NULL,
                    test(# last_name VARCHAR(50) NOT NULL,
                    test(# mobile VARCHAR(50) NOT NULL,
                    test(# date_of_birth VARCHAR(50) NOT NULL,
                    test(# car_id INT REFERENCES newcar (car_id) ON DELETE CASCADE);

            before : select * from newcustomer join newcar on newcustomer.car_id = newcar.car_id;
                    
                    id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id | model  |   make   |  price  
                    ----+------------+-----------+------------+---------------+--------+--------+--------+----------+---------
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      2 |      2 | Thar   | Mahindra | 1500000
                    3 | Shourya    | Aggarwal  | 9911163459 | 2001-12-05    |      1 |      1 | WagonR | Maruti   |  600000
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Swift  | Maruti   |  900000
                    (3 rows)

            After: DELETE FROM newcar WHERE car_id = 1;

                    id | first_name | last_name |   mobile   | date_of_birth | car_id 
                    ----+------------+-----------+------------+---------------+--------
                    1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      2
                    2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4
                    (2 rows)

                    record deleted from child table.

    
    CTE(COMMON TABLE EXPRESSION)
        - used to store result of query as table for a single query

        - WITH CTE AS(
        test(# SELECT * FROM person JOIN car ON person.car_id = car.car_id) SELECT * FROM CTE;

        Result:

            id | first_name | last_name |   mobile   | date_of_birth | car_id | car_id |   make   | model  |  price  
            ----+------------+-----------+------------+---------------+--------+--------+----------+--------+---------
            1 | Avneet     | Singh     | 9911164879 | 2001-07-19    |      3 |      3 | Hyundai  | Creta  | 1500000
            2 | Deepak     | Chaudhary | 8763264879 | 1998-07-24    |      4 |      4 | Maruti   | Swift  |  900000
            4 | Karan      | Pant      | 5611112567 | 1996-06-10    |      1 |      1 | Maruti   | WagonR |  600000
            5 | Kamal      | Singh     | 9437802859 | 2000-10-09    |      2 |      2 | Mahindra | Thar   | 1500000
            (4 rows)


    
    UNION CLAUSE-
        - used to combine the results of two or more SELECT statements without returning any duplicate rows.

        Example: select * from employee where dept_id = 2
                    union 
                    select * from employee where dept_id = 3;
        Result:    emp_id | f_name |  l_name  |      email      | dept_id |    dob     
                    --------+--------+----------+-----------------+---------+------------
                        1 | Avneet | Singh    | avneet@comp.com |       2 | 2001-07-19
                        2 | Karan  | Aggarwal | karan@comp.com  |       3 | 1988-01-25
                        3 | Sameer | Grover   | sameer@comp.com |       2 | 1998-04-04
                    (3 rows)


        - union all clause can be used to return duplicate values too.

        Example:  select * from employee where dept_id = 2
                    union all 
                    select * from employee where dept_id = 3 or dept_id = 2;
        Result:    emp_id | f_name |  l_name  |      email      | dept_id |    dob     
                    --------+--------+----------+-----------------+---------+------------
                        1 | Avneet | Singh    | avneet@comp.com |       2 | 2001-07-19
                        3 | Sameer | Grover   | sameer@comp.com |       2 | 1998-04-04
                        1 | Avneet | Singh    | avneet@comp.com |       2 | 2001-07-19
                        2 | Karan  | Aggarwal | karan@comp.com  |       3 | 1988-01-25
                        3 | Sameer | Grover   | sameer@comp.com |       2 | 1998-04-04
                    (5 rows)



    TRIGGERS
        - used to tell database to perform certain operations by itself after certain actions from user

        Example: 

        Creating a function that contains the operation 

        Command:    CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
                    BEGIN
                    INSERT INTO audit(emp_id, entry_date) VALUES (new.ID, current_timestamp);
                    RETURN NEW;
                    END;
                    $example_table$ LANGUAGE plpgsql;
        Result:     CREATE FUNCTION

        After function we create trigger and link it with the function 

        Command:CREATE TRIGGER example_trigger AFTER INSERT ON employee
                FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

        Result: CREATE TRIGGER

        Tables before any insertion by used in employee

        test=# select * from employee;
                 id | name 
                ----+------
                (0 rows)

                test=# select * from audit;
                 emp_id | entry_date 
                --------+------------
                (0 rows)


        Tables after insertion

        test=# select * from employee;
                id |  name  
                ----+--------
                1 | Avneet
                (1 row)

                test=# select * from audit; (this table is updated automatically)
                emp_id |            entry_date            
                --------+----------------------------------
                    1 | 2023-10-30 14:19:00.228271+05:30
                (1 row)
            